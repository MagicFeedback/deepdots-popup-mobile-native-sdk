/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["magicfeedback"] = factory();
	else
		root["magicfeedback"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/cross-fetch/dist/browser-ponyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/cross-fetch/dist/browser-ponyfill.js ***!
  \***********************************************************/
/***/ (function(module, exports) {

eval("var global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports[\"default\"] = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n\n\n//# sourceURL=webpack://magicfeedback/./node_modules/cross-fetch/dist/browser-ponyfill.js?");

/***/ }),

/***/ "./src/config-globals.ts":
/*!*******************************!*\
  !*** ./src/config-globals.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HOST_API_URL_DEV = exports.HOST_API_URL = void 0;\nexports.HOST_API_URL = 'https://api.deepdots.com/';\nexports.HOST_API_URL_DEV = 'https://api-dev.deepdots.com/';\n\n\n//# sourceURL=webpack://magicfeedback/./src/config-globals.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst main_1 = __importDefault(__webpack_require__(/*! ./main */ \"./src/main.ts\"));\nlet instance = null;\nif (!instance) {\n    instance = (0, main_1.default)();\n}\nexports[\"default\"] = instance;\n\n\n//# sourceURL=webpack://magicfeedback/./src/index.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst form_1 = __webpack_require__(/*! ./models/form */ \"./src/models/form.ts\");\nconst config_1 = __webpack_require__(/*! ./models/config */ \"./src/models/config.ts\");\nconst log_1 = __webpack_require__(/*! ./utils/log */ \"./src/utils/log.ts\");\nconst request_service_1 = __webpack_require__(/*! ./services/request.service */ \"./src/services/request.service.ts\");\nconst config_globals_1 = __webpack_require__(/*! ./config-globals */ \"./src/config-globals.ts\");\n/**\n *\n * @returns\n */\nfunction main() {\n    //===============================================\n    // Attributes\n    //===============================================\n    const config = new config_1.Config();\n    let log;\n    /**\n     *\n     * @param options\n     */\n    function init(options) {\n        if (options === null || options === void 0 ? void 0 : options.debug)\n            config.set(\"debug\", options === null || options === void 0 ? void 0 : options.debug);\n        config.set(\"url\", (options === null || options === void 0 ? void 0 : options.env) && (options === null || options === void 0 ? void 0 : options.env) === \"dev\" ? config_globals_1.HOST_API_URL_DEV : config_globals_1.HOST_API_URL);\n        config.set(\"env\", options === null || options === void 0 ? void 0 : options.env);\n        log = new log_1.Log(config);\n        log.log(\"Initialized Magicfeedback\", config);\n    }\n    /**\n     *\n     * @param appId\n     * @param publicKey\n     * @param feedback\n     * @param id\n     * @param completed\n     * @param privateKey\n     * @returns\n     */\n    function send(appId, publicKey, feedback, completed = true, id, privateKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!appId)\n                log.err(\"No appID provided\");\n            if (!publicKey)\n                log.err(\"No publicKey provided\");\n            if (!feedback)\n                log.err(\"No feedback provided\");\n            if (!feedback.answers &&\n                !feedback.profile &&\n                !feedback.metrics &&\n                !feedback.metadata)\n                log.err(\"No feedback data provided\");\n            const url = config.get(\"url\");\n            const body = {\n                integration: appId,\n                publicKey: publicKey,\n                privateKey: privateKey,\n                completed: completed,\n                id: id,\n                feedback: feedback,\n            };\n            try {\n                const res = yield (0, request_service_1.sendFeedback)(url, body, log);\n                log.log(`sent native feedback`);\n                return res;\n            }\n            catch (e) {\n                log.err(`error native feedback`, e);\n                return false;\n            }\n        });\n    }\n    /**\n     *\n     * @param appId\n     * @param publicKey\n     * @returns\n     */\n    function form(appId, publicKey) {\n        if (!appId)\n            log.err(\"No appID provided\");\n        if (!publicKey)\n            log.err(\"No publicKey provided\");\n        return new form_1.Form(config, appId, publicKey);\n    }\n    /**\n     *\n     * @param sessionId\n     * @returns\n     */\n    function session(sessionId) {\n        if (!sessionId)\n            log.err(\"No sessionId provided\");\n        return new form_1.Form(config, sessionId);\n    }\n    //===============================================\n    // Return\n    //===============================================\n    return {\n        // lifecycle\n        init,\n        // requests\n        send,\n        form,\n        session,\n    };\n}\nexports[\"default\"] = main;\n\n\n//# sourceURL=webpack://magicfeedback/./src/main.ts?");

/***/ }),

/***/ "./src/models/History.ts":
/*!*******************************!*\
  !*** ./src/models/History.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.History = void 0;\nclass History {\n    constructor() {\n        this.items = [];\n    }\n    // Adds an element to the back of the queue\n    enqueue(element) {\n        this.items.push(element);\n    }\n    // Removes the element from the front of the queue\n    dequeue() {\n        return this.items.shift();\n    }\n    // Removes the element from the back of the queue\n    rollback() {\n        return this.items.pop();\n    }\n    // Returns the element at the front of the queue without removing it\n    front() {\n        return this.items[0];\n    }\n    // Returns the element at the back of the queue without removing it\n    back() {\n        return this.items[this.items.length - 1];\n    }\n    // Checks if the queue is empty\n    isEmpty() {\n        return this.items.length === 0;\n    }\n    // Returns the number of elements in the queue\n    size() {\n        return this.items.length;\n    }\n    // Return the element by index\n    get(index) {\n        return this.items[index];\n    }\n}\nexports.History = History;\n\n\n//# sourceURL=webpack://magicfeedback/./src/models/History.ts?");

/***/ }),

/***/ "./src/models/config.ts":
/*!******************************!*\
  !*** ./src/models/config.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Config = void 0;\nclass Config {\n    constructor() {\n        this.variables = {};\n        this.variables[\"env\"] = 'prod';\n        this.variables[\"debug\"] = false;\n    }\n    get(key) {\n        return this.variables[key];\n    }\n    set(key, value) {\n        this.variables[key] = value;\n    }\n}\nexports.Config = Config;\n\n\n//# sourceURL=webpack://magicfeedback/./src/models/config.ts?");

/***/ }),

/***/ "./src/models/form.ts":
/*!****************************!*\
  !*** ./src/models/form.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Form = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/models/types.ts\");\nconst log_1 = __webpack_require__(/*! ../utils/log */ \"./src/utils/log.ts\");\nconst request_service_1 = __webpack_require__(/*! ../services/request.service */ \"./src/services/request.service.ts\");\nconst questions_service_1 = __webpack_require__(/*! ../services/questions.service */ \"./src/services/questions.service.ts\");\nconst pageGrafs_1 = __webpack_require__(/*! ./pageGrafs */ \"./src/models/pageGrafs.ts\");\nconst page_1 = __webpack_require__(/*! ./page */ \"./src/models/page.ts\");\nconst pageRoute_1 = __webpack_require__(/*! ./pageRoute */ \"./src/models/pageRoute.ts\");\nconst History_1 = __webpack_require__(/*! ./History */ \"./src/models/History.ts\");\nconst pageNode_1 = __webpack_require__(/*! ./pageNode */ \"./src/models/pageNode.ts\");\nclass Form {\n    /**\n     *\n     * @param config\n     * @param appId\n     * @param publicKey\n     */\n    constructor(config, appId, publicKey) {\n        // SDK Config\n        this.config = config;\n        this.log = new log_1.Log(config);\n        // Form options\n        this.formOptionsConfig = {\n            addButton: true,\n            sendButtonText: \"Send\",\n            backButtonText: \"Back\",\n            nextButtonText: \"Next\",\n            addSuccessScreen: true,\n            getMetaData: true,\n            questionFormat: \"standard\",\n        };\n        this.selector = \"\";\n        // Attributes\n        this.appId = appId;\n        this.publicKey = publicKey || '';\n        this.url = config.get(\"url\");\n        // Form completed data\n        this.id = \"\";\n        this.formData = null;\n        // if (this.publicKey !== '') this.getDataFromStorage();\n        this.feedback = {\n            text: \"\",\n            answers: [],\n            profile: [],\n            metrics: [],\n            metadata: [],\n        };\n        this.history = new History_1.History();\n        this.graph = new pageGrafs_1.PageGraph([]);\n        // Count variables\n        this.progress = 0;\n        this.total = 0;\n        this.completed = false;\n        this.timeToCompleted = 0;\n    }\n    /**\n     * Get data from the local storage, if the data is older than 24 hours, get the data from the server\n     * @private\n\n     private getDataFromStorage() {\n     const localForm = localStorage.getItem(`magicfeedback-${this.appId}`);\n\n     if (localForm && new Date(JSON.parse(localForm).savedAt) < new Date(new Date().getTime() + 60 * 60 * 24 * 1000)) {\n     this.formData = JSON.parse(localForm);\n     getForm(this.url, this.appId, this.publicKey, this.log).then((form: FormData | null) => {\n     if (form?.updatedAt && this.formData?.savedAt && form?.updatedAt > this.formData?.savedAt) {\n     // console.log(\"Form updated\");\n     this.formData = form;\n     this.formData.savedAt = new Date();\n\n     localStorage.setItem(`magicfeedback-${this.appId}`, JSON.stringify(this.formData));\n\n     if (this.formData.questions === undefined || !this.formData.questions) throw new Error(`No questions for app ${this.appId}`);\n\n     if (!this.formData.pages || this.formData.pages?.length === 0) this.formatPages();\n     this.formData.questions?.sort((a, b) => a.position - b.position);\n     // Clear pages without questions\n     this.formData.pages = this.formData.pages.filter((page) => page.integrationQuestions?.length > 0);\n\n     // Create the form from the JSON\n     this.formData.style?.startMessage ?\n     this.generateWelcomeMessage(this.formData.style.startMessage) :\n     this.startForm();\n     }\n     });\n     }\n     }\n     **/\n    /**\n     * Generate\n     * @param selector\n     * @param options\n     */\n    generate(selector, options) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        return __awaiter(this, void 0, void 0, function* () {\n            // Check options, and set default values if this is not defined\n            try {\n                // Set the options\n                this.formOptionsConfig = Object.assign(Object.assign({}, this.formOptionsConfig), options);\n                this.selector = selector;\n                let resData = this.formData;\n                if (this.formData === undefined || !this.formData)\n                    resData = this.publicKey !== '' ?\n                        yield (0, request_service_1.getForm)(this.url, this.appId, this.publicKey, this.log) :\n                        yield (0, request_service_1.getSessionForm)(this.url, this.appId, this.log);\n                if (resData === undefined || !resData)\n                    throw new Error(`No data for app ${this.appId}`);\n                if ((_a = resData.error) === null || _a === void 0 ? void 0 : _a.message)\n                    throw new Error(resData.error.message);\n                // Clear questions without status ACTIVE\n                resData.questions = ((_b = resData.questions) === null || _b === void 0 ? void 0 : _b.filter((q) => q.status === 'ACTIVE')) || [];\n                resData.pages = ((_c = resData.pages) === null || _c === void 0 ? void 0 : _c.filter((p) => p.status === 'ACTIVE')) || [];\n                ((_d = resData.pages) === null || _d === void 0 ? void 0 : _d.forEach((p) => { var _a; return p.integrationQuestions = (_a = p.integrationQuestions) === null || _a === void 0 ? void 0 : _a.filter((q) => q.status === 'ACTIVE'); })) || [];\n                this.formData = resData;\n                if (!this.formData.savedAt) {\n                    // Save formData in the localstorage to use it in the future\n                    this.formData.savedAt = new Date();\n                    localStorage.setItem(`magicfeedback-${this.appId}`, JSON.stringify(this.formData));\n                }\n                if (this.formData.questions === undefined || !this.formData.questions)\n                    throw new Error(`No questions for app ${this.appId}`);\n                if (!this.formData.pages || ((_e = this.formData.pages) === null || _e === void 0 ? void 0 : _e.length) === 0)\n                    this.formatPages();\n                (_f = this.formData.questions) === null || _f === void 0 ? void 0 : _f.sort((a, b) => a.position - b.position);\n                // Clear pages without questions\n                this.formData.pages = this.formData.pages.filter((page) => { var _a; return ((_a = page.integrationQuestions) === null || _a === void 0 ? void 0 : _a.length) > 0; });\n                if (this.formOptionsConfig.getMetaData)\n                    this.getMetaData();\n                // If this.formData.product.originAllowed exists, check if the current domain is in the list\n                // EJ originAllowed :[\"*\", \"survey.99thstudio.com\"]\n                // \"*\" means that: all domains from deepdots.com are allowed\n                // if is development, dont check the origin\n                /* if (this.config.get('env') !== 'dev' && this.formData.product.originAllowed && this.formData.product.originAllowed.length > 0) {\n                    const domain = window.location.hostname;\n                    const allowed = this.formData.product.originAllowed.find((d: string) => d === domain || (d === '*' && domain.endsWith('.deepdots.com') || d === '*' && domain.endsWith('.magicfeedback.io')));\n                    if (!allowed) throw new Error(`Domain not allowed`);\n                } */\n                ((_g = this.formData.style) === null || _g === void 0 ? void 0 : _g.startMessage) ?\n                    yield this.generateWelcomeMessage(this.formData.style.startMessage) :\n                    this.startForm();\n            }\n            catch (e) {\n                this.log.err(e);\n                if (this.formOptionsConfig.onLoadedEvent) {\n                    yield this.formOptionsConfig.onLoadedEvent({\n                        loading: false,\n                        error: e,\n                    });\n                }\n                return;\n            }\n        });\n    }\n    /**\n     * Format pages in case of the survey don't have pages\n     * @private\n     */\n    formatPages() {\n        var _a;\n        if (!this.formData)\n            return;\n        switch (this.formData.identity) {\n            case 'MAGICSURVEY':\n                // In this case we will create a page for each question\n                this.formData.pages = [];\n                (_a = this.formData.questions) === null || _a === void 0 ? void 0 : _a.forEach((question) => {\n                    var _a, _b;\n                    const route = new pageRoute_1.PageRoute(question.id, question.ref, pageRoute_1.OperatorType.NOEQUAL, [], pageRoute_1.TransitionType.PAGE, (question.position + 1).toString(), question.position.toString());\n                    const page = new page_1.Page(question.position.toString(), question.position, this.appId, [question], [route]);\n                    (_b = (_a = this.formData) === null || _a === void 0 ? void 0 : _a.pages) === null || _b === void 0 ? void 0 : _b.push(page);\n                });\n                break;\n            case 'MAGICFORM':\n                // In this case we will create a page with all the questions\n                const page = new page_1.Page('1', 1, this.appId, this.formData.questions, []);\n                this.formData.pages = [page];\n                break;\n        }\n    }\n    /**\n     * Generate container\n     * @returns\n     */\n    generateContainer() {\n        // Select and prepare the container\n        let container = document.getElementById(this.selector);\n        if (!container) {\n            container = document.getElementById(\"magicfeedback-container-\" + this.appId);\n            if (!container)\n                throw new Error(`Element with ID '${this.selector}' not found.`);\n        }\n        container.classList.add(\"magicfeedback-container\");\n        container.id = \"magicfeedback-container-\" + this.appId;\n        container.innerHTML = \"\";\n        return container;\n    }\n    /**\n     * Generate form\n     * @private\n     * @returns void\n     */\n    generateForm() {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                console.log('Generating form for appId:', this.appId);\n                if (!this.formData || !this.formData.pages || this.formData.pages.length === 0) {\n                    throw new Error(\"No form data\");\n                }\n                this.graph = new pageGrafs_1.PageGraph(this.formData.pages.sort((a, b) => a.position - b.position));\n                // Select and prepare the container\n                let container = this.generateContainer();\n                // Create the form\n                const form = document.createElement(\"form\");\n                form.classList.add(\"magicfeedback-form\");\n                form.id = \"magicfeedback-\" + this.appId;\n                // Prevent reload on submit\n                form.addEventListener(\"submit\", (event) => event.preventDefault());\n                // Create the questions container\n                const questionContainer = document.createElement(\"div\");\n                questionContainer.classList.add(\"magicfeedback-questions\");\n                questionContainer.id = \"magicfeedback-questions-\" + this.appId;\n                const page = this.graph.getFirstPage();\n                if (!page)\n                    throw new Error(\"No page found\");\n                this.total = this.graph.findMaxDepth();\n                // Process questions and create in the form\n                page.elements = (0, questions_service_1.renderQuestions)(page.questions, this.formOptionsConfig.questionFormat, (_a = this.formData) === null || _a === void 0 ? void 0 : _a.lang[0], (_b = this.formData) === null || _b === void 0 ? void 0 : _b.product, () => this.send());\n                (_c = page.elements) === null || _c === void 0 ? void 0 : _c.forEach((element) => questionContainer.appendChild(element));\n                form.appendChild(questionContainer);\n                // Add the new page to the history\n                this.history.enqueue(page);\n                // Add the form to the specified container\n                container.appendChild(form);\n                // Update the progress\n                this.progress = this.total - this.graph.findMaxDepth(page);\n                // Submit button\n                if (this.formOptionsConfig.addButton) {\n                    // Create a container for the buttons\n                    const actionContainer = (0, questions_service_1.renderActions)((_d = this.formData) === null || _d === void 0 ? void 0 : _d.identity, () => this.back(), this.formOptionsConfig.sendButtonText, this.formOptionsConfig.backButtonText, this.formOptionsConfig.nextButtonText);\n                    form.appendChild(actionContainer);\n                }\n                if (this.formOptionsConfig.addButton) {\n                    // Submit event\n                    form.addEventListener(\"submit\", (event) => {\n                        event.preventDefault();\n                        this.send();\n                    });\n                }\n                // init time to complete in seconds\n                this.timeToCompleted = new Date().getTime() / 1000;\n                // Send the data to manage loadings and progress\n                if (this.formOptionsConfig.onLoadedEvent) {\n                    yield this.formOptionsConfig.onLoadedEvent({\n                        loading: false,\n                        progress: this.progress,\n                        total: this.total,\n                        formData: this.formData,\n                    });\n                }\n            }\n            catch (e) {\n                this.log.err(e);\n                if (this.formOptionsConfig.onLoadedEvent) {\n                    this.formOptionsConfig.onLoadedEvent({\n                        loading: false,\n                        error: e,\n                    });\n                }\n                return;\n            }\n        });\n    }\n    /**\n     * Start form after the welcome message, mainly used in the start message\n     * @public\n     **/\n    startForm() {\n        this.generateForm();\n    }\n    /**\n     * Generate welcome message page if the form has a start message,with a button to start the form\n     * @private\n     */\n    generateWelcomeMessage(startMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Select and prepare the container\n                const container = this.generateContainer();\n                const initialMessage = (0, questions_service_1.renderStartMessage)(startMessage, this.formOptionsConfig.addButton, this.formOptionsConfig.startButtonText, () => this.startForm());\n                container.appendChild(initialMessage);\n                // Send the data to manage loadings and progress\n                if (this.formOptionsConfig.onLoadedEvent) {\n                    yield this.formOptionsConfig.onLoadedEvent({\n                        loading: false,\n                        formData: this.formData,\n                    });\n                }\n            }\n            catch (e) {\n                this.log.err(e);\n                if (this.formOptionsConfig.onLoadedEvent) {\n                    this.formOptionsConfig.onLoadedEvent({\n                        loading: false,\n                        error: e,\n                    });\n                }\n                return;\n            }\n        });\n    }\n    /**\n     * Get the metadata from the URL, navigators and others\n     * @private\n     */\n    getMetaData() {\n        // Add the navigator url and params from the URL to the metadata\n        this.feedback.metadata.push({ key: \"navigator-url\", value: [window.location.href] });\n        this.feedback.metadata.push({ key: \"navigator-origin\", value: [window.location.origin] });\n        this.feedback.metadata.push({ key: \"navigator-pathname\", value: [window.location.pathname] });\n        this.feedback.metadata.push({ key: \"navigator-search\", value: [window.location.search] });\n        // Add the navigator metadata\n        this.feedback.metadata.push({ key: \"navigator-user\", value: [navigator.userAgent] });\n        this.feedback.metadata.push({ key: \"navigator-language\", value: [navigator.language] });\n        this.feedback.metadata.push({ key: \"navigator-platform\", value: [navigator.platform] });\n        this.feedback.metadata.push({ key: \"navigator-appVersion\", value: [navigator.appVersion] });\n        this.feedback.metadata.push({ key: \"navigator-appName\", value: [navigator.appName] });\n        this.feedback.metadata.push({ key: \"navigator-product\", value: [navigator.product] });\n        // Add the size of the screen\n        this.feedback.metadata.push({ key: \"screen-width\", value: [window.screen.width.toString()] });\n        this.feedback.metadata.push({ key: \"screen-height\", value: [window.screen.height.toString()] });\n        if (this.appId && this.publicKey === '') {\n            // Add the session id to the metadata\n            this.feedback.metadata.push({ key: \"MAGICFEEDBACK_SESSION\", value: [this.appId] });\n        }\n    }\n    /**\n     * Send current answer and verify if its necessary continue with a new question\n     * @pubilc\n     * @param profile\n     * @param metrics\n     * @param metadata\n     */\n    send(metadata, metrics, profile) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const questionContainer = document.getElementById(\"magicfeedback-questions-\" + this.appId);\n            try {\n                if (profile)\n                    this.feedback.profile = [...this.feedback.profile, ...profile];\n                if (metrics)\n                    this.feedback.metrics = [...this.feedback.metrics, ...metrics];\n                if (metadata)\n                    this.feedback.metadata = [...this.feedback.metadata, ...metadata];\n                // Get the survey answers from the answer() function\n                this.answer();\n                // BEFORE\n                if (this.formOptionsConfig.beforeSubmitEvent) {\n                    yield this.formOptionsConfig.beforeSubmitEvent({\n                        loading: true,\n                        // answer: this.feedback.answers,\n                        progress: this.progress,\n                        total: this.total\n                    });\n                }\n                // Check if the required questions are answered\n                const page = this.history.back();\n                if (!page)\n                    throw new Error(\"No page found\");\n                for (const question of page.questions.filter(question => question.require &&\n                    ![types_1.FEEDBACKAPPANSWERTYPE.CONSENT, types_1.FEEDBACKAPPANSWERTYPE.INFO_PAGE].includes(question.type))) {\n                    const assets = question.assets;\n                    const ans = this.feedback.answers.filter((a) => a.key.includes(question.ref) && !a.key.includes('extra-option'));\n                    if (ans.length === 0 ||\n                        ans.find((a) => a.value.length === 0)) {\n                        this.log.err(`The question ${question.ref} is required`);\n                        throw new Error(`No response`);\n                    }\n                    if (assets === null || assets === void 0 ? void 0 : assets.minOptions) {\n                        let exclusiveAnswers = [];\n                        if (assets === null || assets === void 0 ? void 0 : assets.exclusiveAnswers) {\n                            exclusiveAnswers = assets === null || assets === void 0 ? void 0 : assets.exclusiveAnswers;\n                        }\n                        // Check if the question has the minimum number of options selected and the exclusiveAnswers if it exists\n                        if (!ans[0].value.find((a) => exclusiveAnswers.includes(a)) &&\n                            ans[0].value.length < (assets === null || assets === void 0 ? void 0 : assets.minOptions)) {\n                            this.log.err(`The question ${question.ref} requires at least ${assets === null || assets === void 0 ? void 0 : assets.minOptions} options`);\n                            throw new Error(`No response`);\n                        }\n                    }\n                }\n                // SEND\n                const response = yield this.pushAnswers(false);\n                if (!response)\n                    throw new Error(\"No response\");\n                this.id = response;\n                yield this.processNextQuestion(questionContainer);\n            }\n            catch (error) {\n                // Handle error in beforeSubmitEvent, send(), or afterSubmitEvent\n                this.log.err(`An error occurred while submitting the form ${this.appId}:`, error);\n                if (this.formOptionsConfig.afterSubmitEvent) {\n                    yield this.formOptionsConfig.afterSubmitEvent({\n                        loading: false,\n                        progress: this.progress,\n                        total: this.total,\n                        error\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * Update feedback -> answers with the answers of the form in a JSON format\n     * @returns\n     * @public\n     */\n    answer() {\n        const form = document.getElementById(\"magicfeedback-\" + this.appId);\n        if (!form) {\n            this.log.err(`Form \"${form}\" not found.`);\n            this.feedback.answers = [];\n            return;\n        }\n        // Check if the required questions are answered\n        const page = this.history.back();\n        if (!page)\n            throw new Error(\"No page found\");\n        const surveyAnswers = [];\n        let hasError = false; // Flag to track if an error has occurred\n        const inputs = form.querySelectorAll(\".magicfeedback-input\");\n        inputs.forEach((input) => {\n            const question = page.questions.find(q => { var _a; return (_a = input.name) === null || _a === void 0 ? void 0 : _a.includes(q.ref); });\n            const inputType = input.type;\n            const elementTypeClass = input.classList[0];\n            const ans = {\n                key: input.name,\n                value: [],\n            };\n            const value = elementTypeClass === 'magicfeedback-consent' ?\n                input.checked.toString() :\n                input.value;\n            if (!ans.key || ans.key === \"\")\n                return;\n            switch (question === null || question === void 0 ? void 0 : question.type) {\n                case types_1.FEEDBACKAPPANSWERTYPE.EMAIL:\n                case types_1.FEEDBACKAPPANSWERTYPE.TEXT:\n                case types_1.FEEDBACKAPPANSWERTYPE.LONGTEXT:\n                case types_1.FEEDBACKAPPANSWERTYPE.NUMBER:\n                case types_1.FEEDBACKAPPANSWERTYPE.DATE:\n                case types_1.FEEDBACKAPPANSWERTYPE.CONTACT:\n                    if (value !== \"\") {\n                        if (inputType === \"email\") {\n                            if (!(0, request_service_1.validateEmail)(value)) {\n                                this.log.err(\"Invalid email\");\n                                hasError = true;\n                                break;\n                            }\n                            else {\n                                this.feedback.profile.push({\n                                    key: \"email\",\n                                    value: [value],\n                                });\n                            }\n                        }\n                        ans.value.push(value);\n                    }\n                    break;\n                case types_1.FEEDBACKAPPANSWERTYPE.CONSENT:\n                    ans.value.push(String(input.checked));\n                    break;\n                case types_1.FEEDBACKAPPANSWERTYPE.POINT_SYSTEM:\n                    const key = input.id;\n                    ans.value.push(`${key}:${value}%`);\n                    break;\n                case types_1.FEEDBACKAPPANSWERTYPE.MULTIPLECHOICE:\n                case types_1.FEEDBACKAPPANSWERTYPE.MULTIPLECHOISE_IMAGE:\n                case types_1.FEEDBACKAPPANSWERTYPE.RATING_STAR:\n                case types_1.FEEDBACKAPPANSWERTYPE.RADIO:\n                case types_1.FEEDBACKAPPANSWERTYPE.RATING_EMOJI:\n                case types_1.FEEDBACKAPPANSWERTYPE.RATING_NUMBER:\n                    if (input.checked || input.id.includes(\"extra-option-\")) {\n                        ans.value.push(value);\n                    }\n                    break;\n                case types_1.FEEDBACKAPPANSWERTYPE.SELECT:\n                    ans.value.push(value);\n                    break;\n                case types_1.FEEDBACKAPPANSWERTYPE.BOOLEAN:\n                    if (input.checked) {\n                        ans.value.push(value);\n                    }\n                    break;\n                case types_1.FEEDBACKAPPANSWERTYPE.MULTI_QUESTION_MATRIX:\n                    if (input.checked) {\n                        ans.value.push(value);\n                    }\n                    break;\n                case types_1.FEEDBACKAPPANSWERTYPE.PRIORITY_LIST:\n                    ans.value.push(value);\n                    break;\n                default:\n                    break;\n            }\n            if ((surveyAnswers === null || surveyAnswers === void 0 ? void 0 : surveyAnswers.length) > 0 && (surveyAnswers === null || surveyAnswers === void 0 ? void 0 : surveyAnswers.find(a => a.key === ans.key))) {\n                const index = surveyAnswers.findIndex(a => a.key === ans.key);\n                surveyAnswers[index].value = [...surveyAnswers[index].value, ...ans.value];\n            }\n            else {\n                surveyAnswers.push(ans);\n            }\n        });\n        if (hasError) {\n            this.feedback.answers = []; // Stop the process if there's an error\n            page.setAnswer([]);\n            return;\n        }\n        // --- Agrupacin especial para MULTI_QUESTION_MATRIX ---\n        try {\n            const matrixQuestions = page.questions.filter(q => q.type === types_1.FEEDBACKAPPANSWERTYPE.MULTI_QUESTION_MATRIX);\n            matrixQuestions.forEach(mq => {\n                // Respuestas individuales capturadas como ref-rowName\n                const rowPrefix = mq.ref + '-';\n                const rowAnswers = surveyAnswers.filter(a => a.key.startsWith(rowPrefix));\n                if (rowAnswers.length === 0)\n                    return; // nada que agrupar\n                // Crear estructura: [{ key: rowName, value: [selected] }, ...]\n                const groupedRows = rowAnswers.map(r => ({\n                    key: r.key.substring(rowPrefix.length),\n                    value: r.value\n                }));\n                // El formato requerido: valor debe ser un array que contiene (una sola posicin) un array de objetos fila\n                const matrixAnswer = {\n                    key: mq.ref,\n                    value: [JSON.stringify(groupedRows)]\n                };\n                // Eliminar las respuestas individuales\n                for (const ra of rowAnswers) {\n                    const idx = surveyAnswers.findIndex(s => s.key === ra.key);\n                    if (idx !== -1)\n                        surveyAnswers.splice(idx, 1);\n                }\n                // Aadir (o reemplazar si ya existiera) la respuesta agrupada\n                const existingIndex = surveyAnswers.findIndex(a => a.key === mq.ref);\n                if (existingIndex !== -1) {\n                    surveyAnswers[existingIndex] = matrixAnswer;\n                }\n                else {\n                    surveyAnswers.push(matrixAnswer);\n                }\n            });\n        }\n        catch (e) {\n            this.log.err('Error agrupando MULTI_QUESTION_MATRIX', e);\n        }\n        this.feedback.answers = surveyAnswers;\n        page.setAnswer(surveyAnswers);\n    }\n    /**\n     * Finish the form\n     * @public\n     */\n    finish() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.completed = true;\n            this.timeToCompleted = new Date().getTime() - this.timeToCompleted;\n            this.feedback.metadata.push({ key: \"time-to-complete\", value: [this.timeToCompleted.toString()] });\n            if (this.formOptionsConfig.addSuccessScreen) {\n                const container = document.getElementById(\"magicfeedback-container-\" + this.appId);\n                // Remove the form\n                if (container.childNodes.length > 0)\n                    container.removeChild(container.childNodes[0]);\n                // Show the success message\n                const successMessage = (0, questions_service_1.renderSuccess)(this.formOptionsConfig.successMessage ||\n                    \"Thank you for your feedback!\");\n                container.appendChild(successMessage);\n            }\n            this.answer();\n            try {\n                const response = yield this.pushAnswers(true);\n                if (!response) {\n                    if (this.formOptionsConfig.afterSubmitEvent) {\n                        yield this.formOptionsConfig.afterSubmitEvent({\n                            loading: false,\n                            progress: this.progress,\n                            total: this.total,\n                            completed: this.completed,\n                            error: `An error occurred while submitting the form ${this.appId}:`\n                        });\n                    }\n                    throw new Error(\"An error occurred while submitting the form ${this.appId}:\");\n                }\n                this.id = response;\n                // AFTER\n                if (this.formOptionsConfig.afterSubmitEvent) {\n                    yield this.formOptionsConfig.afterSubmitEvent({\n                        response: this.id,\n                        loading: false,\n                        progress: this.progress,\n                        total: this.total,\n                        completed: this.completed,\n                        error: null\n                    });\n                }\n            }\n            catch (error) {\n                // Handle error in beforeSubmitEvent, send(), or afterSubmitEvent\n                this.log.err(`An error occurred while submitting the form ${this.appId}:`, error);\n                if (this.formOptionsConfig.afterSubmitEvent) {\n                    yield this.formOptionsConfig.afterSubmitEvent({\n                        loading: false,\n                        progress: this.progress,\n                        total: this.total,\n                        completed: this.completed,\n                        error\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * Send\n     * @param completed\n     * @returns\n     */\n    pushAnswers(completed = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Define the URL and request payload\n                const url = this.config.get(\"url\");\n                const body = {\n                    integration: this.appId,\n                    publicKey: this.publicKey,\n                    feedback: this.feedback,\n                    completed,\n                };\n                // Make the AJAX POST request\n                return yield (0, request_service_1.sendFeedback)(url, this.id ? Object.assign(Object.assign({}, body), { sessionId: this.id }) : body, this.log);\n            }\n            catch (error) {\n                // Handle network or request error\n                this.log.err(`An error occurred while submitting the form ${this.appId}:`, error);\n                // You can perform error handling logic here if needed\n                return '';\n            }\n        });\n    }\n    /**\n     * Call follow up question\n     * @param question\n     * @private\n     */\n    callFollowUpQuestion(question) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(question === null || question === void 0 ? void 0 : question.followup))\n                return null;\n            try {\n                if (this.feedback.answers.length === 0)\n                    throw new Error(\"No answers provided\");\n                // Define the URL and request payload\n                const url = this.config.get(\"url\");\n                const body = Object.assign(Object.assign(Object.assign({ answer: (_a = this.feedback.answers.find((a) => a.key === question.ref)) === null || _a === void 0 ? void 0 : _a.value[0] }, (this.publicKey !== '' && { publicKey: this.publicKey })), (this.publicKey === '' && { campaignSessionId: this.appId })), { sessionId: this.id, question });\n                return yield (0, request_service_1.getFollowUpQuestion)(url, body, this.log);\n            }\n            catch (error) {\n                // Handle network or request error\n                this.log.err(`An error occurred while submitting the form ${this.appId}:`, error);\n                // You can perform error handling logic here if needed\n                throw error;\n            }\n        });\n    }\n    /**\n     * Process next question\n     * @param form\n     * @private\n     */\n    processNextQuestion(form) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            const page = this.history.back();\n            if (!page)\n                throw new Error(\"No page found\");\n            const followUpList = page.getFollowupQuestions();\n            if ((followUpList === null || followUpList === void 0 ? void 0 : followUpList.length) === 0) {\n                yield this.renderNextQuestion(form, page);\n                return;\n            }\n            const followUpQuestions = [];\n            for (const followUp of followUpList) {\n                const question = page.questions.find((q) => q.ref === followUp);\n                if (question) {\n                    const followUpQuestion = yield this.callFollowUpQuestion(question);\n                    if (followUpQuestion)\n                        followUpQuestions.push(followUpQuestion);\n                }\n            }\n            if (followUpQuestions.length === 0) {\n                yield this.renderNextQuestion(form, page);\n                return;\n            }\n            // Create a new page with the follow up questions\n            const newPage = new page_1.Page(page.id, page.position, this.appId, followUpQuestions, page.edges);\n            const n = new pageNode_1.PageNode(page.id, page.position, page.edges, newPage, followUpQuestions, true);\n            n.elements = (0, questions_service_1.renderQuestions)(followUpQuestions, this.formOptionsConfig.questionFormat, (_a = this.formData) === null || _a === void 0 ? void 0 : _a.lang[0], (_b = this.formData) === null || _b === void 0 ? void 0 : _b.product, () => this.send());\n            // Update the progress +0.5, because the follow up questions are\n            // not included in the graph and one page with follow up questions is considered as 2\n            this.history.enqueue(n);\n            this.progress += 0.5;\n            form.innerHTML = \"\";\n            (_c = n.elements) === null || _c === void 0 ? void 0 : _c.forEach((element) => form.appendChild(element));\n            // AFTER\n            if (this.formOptionsConfig.afterSubmitEvent) {\n                yield this.formOptionsConfig.afterSubmitEvent({\n                    response: this.id,\n                    loading: false,\n                    progress: this.progress,\n                    total: this.total,\n                    followup: n.isFollowup,\n                    completed: this.completed,\n                    error: null\n                });\n            }\n        });\n    }\n    /**\n     * Render next question\n     * @param form\n     * @param page\n     * @private\n     */\n    renderNextQuestion(form, page) {\n        var _a, _b, _c, _d, _e;\n        return __awaiter(this, void 0, void 0, function* () {\n            // Get next page from the graph\n            //console.log(page, this.feedback.answers);\n            let nextPage = this.graph.getNextPage(page, this.feedback.answers);\n            //console.log(nextPage);\n            if (!nextPage) {\n                this.finish();\n                return;\n            }\n            // --- NEW: Check preconditional routes ---\n            const preconditionalRoute = nextPage.edges.filter(edge => edge.typeCondition === 'PRECONDITIONAL').sort((a, b) => {\n                // Sort by position\n                if (a.position < b.position)\n                    return -1;\n                if (a.position > b.position)\n                    return 1;\n                return 0;\n            });\n            if ((preconditionalRoute === null || preconditionalRoute === void 0 ? void 0 : preconditionalRoute.length) > 0) {\n                // Look for the answer in previous PageNodes\n                let foundAnswer = null;\n                const allRefs = preconditionalRoute.map(route => route.questionRef);\n                // Search in the history from the most recent backwards\n                for (let i = this.history.size() - 1; i >= 0; i--) {\n                    const node = this.history.get(i);\n                    if (!node)\n                        continue;\n                    foundAnswer = (_a = node.answers) === null || _a === void 0 ? void 0 : _a.find((ans) => allRefs.includes(ans.key));\n                    if (foundAnswer)\n                        break;\n                }\n                // If there is an answer, evaluate the condition\n                let allowToContinue = !preconditionalRoute.some(route => route.transition === pageRoute_1.TransitionType.ALLOW);\n                if (foundAnswer) {\n                    for (const route of preconditionalRoute) {\n                        let conditionMet = false;\n                        const question = (_b = this.formData) === null || _b === void 0 ? void 0 : _b.questions.find(q => q.ref === route.questionRef);\n                        const answerVals = Array.isArray(foundAnswer.value) ? foundAnswer.value : [foundAnswer.value];\n                        const routeVals = Array.isArray(route.value) ? route.value : [route.value];\n                        // Lgica especial para matrices\n                        if ((question === null || question === void 0 ? void 0 : question.type) === types_1.FEEDBACKAPPANSWERTYPE.MULTI_QUESTION_MATRIX) {\n                            conditionMet = this.evaluateMatrixPreconditional(route, foundAnswer);\n                        }\n                        else {\n                            switch (route.typeOperator) {\n                                case 'EQUAL':\n                                    // At least one answer value equals one expected value\n                                    conditionMet = answerVals.some((v) => routeVals.includes(v));\n                                    break;\n                                case 'NOEQUAL':\n                                    // None of the answer values equals any expected value\n                                    conditionMet = answerVals.every((v) => !routeVals.includes(v));\n                                    break;\n                                case 'GREATER':\n                                    conditionMet = answerVals.some((v) => Number(v) > Number(routeVals[0]));\n                                    break;\n                                case 'LESS':\n                                    conditionMet = answerVals.some((v) => Number(v) < Number(routeVals[0]));\n                                    break;\n                                case 'GREATEREQUAL':\n                                    conditionMet = answerVals.some((v) => Number(v) >= Number(routeVals[0]));\n                                    break;\n                                case 'LESSEQUAL':\n                                    conditionMet = answerVals.some((v) => Number(v) <= Number(routeVals[0]));\n                                    break;\n                                case 'INQ':\n                                    // Some answer value is included in route.value (array)\n                                    conditionMet = answerVals.some((v) => routeVals.includes(v));\n                                    break;\n                                case 'NINQ':\n                                    // No answer value is included in route.value (array)\n                                    conditionMet = answerVals.every((v) => !routeVals.includes(v));\n                                    break;\n                                default:\n                                    break;\n                            }\n                        }\n                        // If condition is met, apply the transition\n                        if (conditionMet) {\n                            this.feedback.answers = [];\n                            switch (route.transition) {\n                                case pageRoute_1.TransitionType.NEXT:\n                                    if (nextPage)\n                                        yield this.renderNextQuestion(form, nextPage);\n                                    return;\n                                case pageRoute_1.TransitionType.ALLOW:\n                                    allowToContinue = true;\n                                    break;\n                            }\n                        }\n                    }\n                }\n                if (!allowToContinue) {\n                    this.feedback.answers = [];\n                    if (nextPage)\n                        yield this.renderNextQuestion(form, nextPage);\n                    return;\n                }\n            }\n            // --- END NEW ---\n            nextPage.elements = (0, questions_service_1.renderQuestions)(nextPage.questions, this.formOptionsConfig.questionFormat, (_c = this.formData) === null || _c === void 0 ? void 0 : _c.lang[0], (_d = this.formData) === null || _d === void 0 ? void 0 : _d.product, () => this.send());\n            form.innerHTML = \"\";\n            (_e = nextPage.elements) === null || _e === void 0 ? void 0 : _e.forEach((element) => form.appendChild(element));\n            this.history.enqueue(nextPage);\n            this.progress = this.total - this.graph.findMaxDepth(nextPage);\n            // AFTER\n            if (this.formOptionsConfig.afterSubmitEvent) {\n                yield this.formOptionsConfig.afterSubmitEvent({\n                    response: this.id,\n                    loading: false,\n                    progress: this.progress,\n                    total: this.total,\n                    followup: nextPage.isFollowup,\n                    completed: this.completed,\n                    error: null\n                });\n            }\n        });\n    }\n    /**\n     * Render back question\n     * @private\n     */\n    back() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.history.size() === 0)\n                return;\n            const form = document.getElementById(\"magicfeedback-questions-\" + this.appId);\n            if (form && form.childNodes.length > 0)\n                form.innerHTML = \"\";\n            this.history.rollback();\n            const page = this.history.back();\n            if (page) {\n                (_a = page.elements) === null || _a === void 0 ? void 0 : _a.forEach((element) => form.appendChild(element));\n                this.progress = this.total - this.graph.findMaxDepth(page);\n            }\n            else {\n                this.progress = this.history.size();\n            }\n            // AFTER\n            if (this.formOptionsConfig.onBackEvent) {\n                yield this.formOptionsConfig.onBackEvent({\n                    loading: false,\n                    progress: this.progress,\n                    followup: (page === null || page === void 0 ? void 0 : page.isFollowup) || false,\n                    error: !page ? \"No page found\" : null\n                });\n            }\n        });\n    }\n    /**\n     * Render a single question as a preview/test.\n     * It does not modify the internal state (history, graph, progress) of the form.\n     * @param selector ID of the container where the question will be injected.\n     * @param question Full question object (NativeQuestion[] expected here).\n     * @param options Optional configuration to customize format/language/product.\n     * @returns HTMLElement container used.\n     */\n    previewQuestion(selector, question, options) {\n        var _a, _b;\n        const questionsArray = Array.isArray(question) ? question : [question];\n        if (!questionsArray || questionsArray.length === 0)\n            throw new Error(\"[MagicFeedback] No question provided for preview\");\n        const container = document.getElementById(selector);\n        if (!container)\n            throw new Error(`[MagicFeedback] Element with ID '${selector}' not found.`);\n        const { format = this.formOptionsConfig.questionFormat || \"standard\", language = (((_a = this.formData) === null || _a === void 0 ? void 0 : _a.lang) && this.formData.lang[0]) || \"en\", product = ((_b = this.formData) === null || _b === void 0 ? void 0 : _b.product) || { customIcons: false }, clearContainer = true, wrap = true, } = options || {};\n        if (clearContainer)\n            container.innerHTML = \"\";\n        // Reuse existing renderQuestions logic passing the question array\n        let elements = [];\n        try {\n            elements = (0, questions_service_1.renderQuestions)(questionsArray, format, language, product);\n        }\n        catch (e) {\n            this.log.err(e);\n            throw e;\n        }\n        // If wrap is true, create a wrapper container to isolate preview styles\n        let target = container;\n        if (wrap) {\n            const wrapper = document.createElement(\"div\");\n            wrapper.classList.add(\"magicfeedback-preview-question\");\n            target.appendChild(wrapper);\n            target = wrapper;\n        }\n        elements.forEach(el => target.appendChild(el));\n        return container;\n    }\n    parseMatrixAnswerPre(ans) {\n        if (!ans || !ans.value)\n            return [];\n        if (ans.value.length === 1 && typeof ans.value[0] === 'string' && ans.value[0].trim().startsWith('[')) {\n            try {\n                const parsed = JSON.parse(ans.value[0]);\n                if (Array.isArray(parsed))\n                    return parsed;\n            }\n            catch (_) {\n                return [];\n            }\n        }\n        if (Array.isArray(ans.value) && ans.value.length > 0 && typeof ans.value[0] === 'object' && ans.value[0] !== null && 'key' in ans.value[0]) {\n            return ans.value;\n        }\n        return [];\n    }\n    evaluateMatrixPreconditional(route, answer) {\n        const edgeVals = Array.isArray(route.value) ? route.value : [route.value];\n        const optionFilter = new Set(route.option || []);\n        const rows = this.parseMatrixAnswerPre(answer);\n        if (!rows.length)\n            return false;\n        const relevantRows = optionFilter.size > 0 ? rows.filter(r => optionFilter.has(r.key)) : rows;\n        if (!relevantRows.length)\n            return false;\n        const intersects = (rowValues) => rowValues.some(v => edgeVals.includes(v));\n        const notIntersects = (rowValues) => rowValues.every(v => !edgeVals.includes(v));\n        switch (route.typeOperator) {\n            case 'EQUAL':\n            case 'INQ':\n                return relevantRows.some(r => intersects(Array.isArray(r.value) ? r.value : [r.value]));\n            case 'NOEQUAL':\n            case 'NINQ':\n                return relevantRows.every(r => notIntersects(Array.isArray(r.value) ? r.value : [r.value]));\n            case 'GREATER':\n                return relevantRows.some(r => {\n                    const vals = Array.isArray(r.value) ? r.value : [r.value];\n                    return vals.some(val => edgeVals.some(edgeVal => Number(val) > Number(edgeVal)));\n                });\n            case 'LESS':\n                return relevantRows.some(r => {\n                    const vals = Array.isArray(r.value) ? r.value : [r.value];\n                    return vals.some(val => edgeVals.some(edgeVal => Number(val) < Number(edgeVal)));\n                });\n            case 'GREATEREQUAL':\n                return relevantRows.some(r => {\n                    const vals = Array.isArray(r.value) ? r.value : [r.value];\n                    return vals.some(val => edgeVals.some(edgeVal => Number(val) >= Number(edgeVal)));\n                });\n            case 'LESSEQUAL':\n                return relevantRows.some(r => {\n                    const vals = Array.isArray(r.value) ? r.value : [r.value];\n                    return vals.some(val => edgeVals.some(edgeVal => Number(val) <= Number(edgeVal)));\n                });\n            default:\n                return false;\n        }\n    }\n}\nexports.Form = Form;\n\n\n//# sourceURL=webpack://magicfeedback/./src/models/form.ts?");

/***/ }),

/***/ "./src/models/page.ts":
/*!****************************!*\
  !*** ./src/models/page.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Page = void 0;\nclass Page {\n    constructor(id, position, integrationId, integrationQuestions, integrationPageRoutes) {\n        this.id = id;\n        this.position = position;\n        this.generatedAt = new Date().toISOString();\n        this.updatedAt = new Date().toISOString();\n        this.status = 'ACTIVE';\n        this.integrationId = integrationId;\n        this.integrationQuestions = integrationQuestions;\n        this.integrationPageRoutes = integrationPageRoutes;\n    }\n}\nexports.Page = Page;\n\n\n//# sourceURL=webpack://magicfeedback/./src/models/page.ts?");

/***/ }),

/***/ "./src/models/pageGrafs.ts":
/*!*********************************!*\
  !*** ./src/models/pageGrafs.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PageGraph = void 0;\nconst pageNode_1 = __webpack_require__(/*! ./pageNode */ \"./src/models/pageNode.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/models/types.ts\");\nconst pageRoute_1 = __webpack_require__(/*! ./pageRoute */ \"./src/models/pageRoute.ts\");\nclass PageGraph {\n    constructor(pages) {\n        this.nodes = new Map();\n        this.buildGraph(pages);\n    }\n    /**\n     * Build the graph from the list of pages\n     * @param pages\n     * @private\n     * */\n    buildGraph(pages) {\n        pages.forEach((page) => {\n            var _a;\n            // Sort by created date and then by type of transition (logical first)\n            if (page.integrationPageRoutes)\n                page.integrationPageRoutes = ((_a = page.integrationPageRoutes) === null || _a === void 0 ? void 0 : _a.sort((a, b) => (new Date((a === null || a === void 0 ? void 0 : a.generatedAt) || '').getTime() - new Date((b === null || b === void 0 ? void 0 : b.generatedAt) || '').getTime() || 0) &&\n                    (a.typeCondition === 'DIRECT' ? 1 : -1))) || [];\n            const node = new pageNode_1.PageNode(page.id, page.position, page.integrationPageRoutes || [], page, page.integrationQuestions);\n            this.nodes.set(node.id, node);\n        });\n    }\n    getNodeById(id) {\n        return this.nodes.get(id);\n    }\n    /**\n     * Get the next page position of the graph given the current page and the answer\n     * @param node\n     */\n    getNextEdgeByDefault(node) {\n        if (!node)\n            return undefined;\n        const direct = node.edges.find((e) => e.typeCondition === pageRoute_1.ConditionType.DIRECT);\n        if (direct && [pageRoute_1.TransitionType.FINISH, pageRoute_1.TransitionType.REDIRECT].includes(direct.transition))\n            return undefined;\n        if (direct && direct.transitionDestiny)\n            return direct.transitionDestiny;\n        for (const n of this.nodes.values()) {\n            if (n.position === (node.position + 1))\n                return n.id;\n        }\n        return undefined;\n    }\n    /**\n     * Get the first page of the graph\n     * @returns first page\n     **/\n    getFirstPage() {\n        // Find the page with the smallest position\n        // TODO: Chek if the graph is completed and don't have break loops\n        let firstPage;\n        let smallestPosition = Number.MAX_VALUE;\n        for (const node of this.nodes.values()) {\n            if (node.position < smallestPosition) {\n                smallestPosition = node.position;\n                firstPage = node;\n            }\n        }\n        return firstPage;\n    }\n    /**\n     * Get the next page of the graph given the current page and the answer\n     * @param currentNode\n     * @param answer - answer to the question in the current page\n     * @returns page\n     **/\n    getNextPage(currentNode, answer) {\n        var _a;\n        if (!currentNode) {\n            return undefined;\n        }\n        // Ordenar edges: primero lgicos, luego directos\n        currentNode.edges.sort((a, b) => {\n            if (a.typeCondition === 'DIRECT')\n                return 1;\n            if (b.typeCondition === 'DIRECT')\n                return -1;\n            return 0;\n        });\n        // console.log(currentNode)\n        // Buscar la primera ruta que cumpla la condicin\n        const route = currentNode.edges.find(edge => {\n            // Chequear condicin\n            const question = currentNode.questions.find(q => q.ref === edge.questionRef);\n            const answerValue = answer === null || answer === void 0 ? void 0 : answer.filter(ans => ans.key === edge.questionRef);\n            if (edge.typeCondition === 'DIRECT')\n                return true;\n            if (!answerValue || answerValue.length === 0)\n                return false;\n            // Lgica especial para matrices\n            if ((question === null || question === void 0 ? void 0 : question.type) === types_1.FEEDBACKAPPANSWERTYPE.MULTI_QUESTION_MATRIX) {\n                return this.evaluateMatrixCondition(edge, answerValue);\n            }\n            // Normalizar edge.value a array\n            const edgeVals = Array.isArray(edge.value) ? edge.value : [edge.value];\n            switch (edge.typeOperator) {\n                case pageRoute_1.OperatorType.EQUAL:\n                    return answerValue.some(ans => {\n                        const ansVals = Array.isArray(ans.value) ? ans.value : [ans.value];\n                        return ansVals.some(val => edgeVals.includes(val));\n                    });\n                case pageRoute_1.OperatorType.NOEQUAL:\n                    return answerValue.every(ans => {\n                        const ansVals = Array.isArray(ans.value) ? ans.value : [ans.value];\n                        return ansVals.every(val => !edgeVals.includes(val));\n                    });\n                case pageRoute_1.OperatorType.GREATER:\n                    return answerValue.some(ans => {\n                        const ansVals = Array.isArray(ans.value) ? ans.value : [ans.value];\n                        return ansVals.some(val => edgeVals.some(edgeVal => Number(val) > Number(edgeVal)));\n                    });\n                case pageRoute_1.OperatorType.LESS:\n                    return answerValue.some(ans => {\n                        const ansVals = Array.isArray(ans.value) ? ans.value : [ans.value];\n                        return ansVals.some(val => edgeVals.some(edgeVal => Number(val) < Number(edgeVal)));\n                    });\n                case pageRoute_1.OperatorType.GREATEREQUAL:\n                    return answerValue.some(ans => {\n                        const ansVals = Array.isArray(ans.value) ? ans.value : [ans.value];\n                        return ansVals.some(val => edgeVals.some(edgeVal => Number(val) >= Number(edgeVal)));\n                    });\n                case pageRoute_1.OperatorType.LESSEQUAL:\n                    return answerValue.some(ans => {\n                        const ansVals = Array.isArray(ans.value) ? ans.value : [ans.value];\n                        return ansVals.some(val => edgeVals.some(edgeVal => Number(val) <= Number(edgeVal)));\n                    });\n                case pageRoute_1.OperatorType.INQ:\n                    return answerValue.some(ans => {\n                        const ansVals = Array.isArray(ans.value) ? ans.value : [ans.value];\n                        return ansVals.some(val => edgeVals.includes(val));\n                    });\n                case pageRoute_1.OperatorType.NINQ:\n                    return answerValue.every(ans => {\n                        const ansVals = Array.isArray(ans.value) ? ans.value : [ans.value];\n                        return ansVals.every(val => !edgeVals.includes(val));\n                    });\n                default:\n                    return false;\n            }\n        });\n        // Si no hay ninguna ruta que cumpla, ir a la siguiente pgina por posicin\n        if (!route) {\n            const nextPage = this.getNextEdgeByDefault(currentNode);\n            if (!nextPage)\n                return undefined;\n            return this.getNodeById(nextPage);\n        }\n        switch (route.transition) {\n            case pageRoute_1.TransitionType.PAGE:\n                if (!route.transitionDestiny)\n                    return undefined;\n                return this.getNodeById(route.transitionDestiny);\n            case pageRoute_1.TransitionType.FINISH:\n                return undefined;\n            case pageRoute_1.TransitionType.REDIRECT:\n                window.location.href = ((_a = route.transitionDestiny) === null || _a === void 0 ? void 0 : _a.includes('?')) ? `${route.transitionDestiny}&${window.location.search.slice(1)}`\n                    : `${route.transitionDestiny}${window.location.search}`;\n                return undefined;\n            default:\n                return undefined;\n        }\n    }\n    /**\n     * Get the number deep (DFS) of this node\n     * @param id - node id\n     * @returns DFS number\n     */\n    findDepth(id) {\n        const node = this.getNodeById(id);\n        if (!node) {\n            return 0;\n        }\n        const visited = new Set();\n        return this.DFSUtil(node, visited, 0);\n    }\n    /**\n     * Get the max depth of the graph\n     * @param n - node\n     * @returns max depth\n     */\n    findMaxDepth(n) {\n        // Find first node\n        if (!n)\n            n = this.getFirstPage();\n        if (!n)\n            return 0;\n        // Start DFS from the first node\n        const visited = new Set();\n        // const haveFollowup = !!n.questions.find(q => q.followup);\n        //console.log(this.nodes);\n        // If the first node have followup questions, the depth is 2\n        let max_depth = 1; // haveFollowup ? 2 : 1;\n        max_depth = Math.max(max_depth, this.DFSUtil(n, visited, max_depth));\n        return max_depth;\n    }\n    /**\n     * A function used by DFS\n     * @param v - node\n     * @param visited - set of visited nodes\n     * @param depth - current depth\n     */\n    DFSUtil(v, visited, depth) {\n        visited.add(v);\n        let max_depth = depth;\n        // Haz una copia local de los vecinos para evitar modificar el grafo original\n        const neighbours = [...(v.edges.filter((e) => e.typeCondition !== pageRoute_1.ConditionType.PRECONDITIONAL) || [])];\n        // Si no hay edges, ir a la siguiente pgina por posicin\n        const defaultEdge = this.getNextEdgeByDefault(v);\n        if (defaultEdge) {\n            const defaultNode = this.getNodeById(defaultEdge);\n            if (defaultNode && !visited.has(defaultNode)) {\n                neighbours.push(new pageRoute_1.PageRoute(defaultNode.id, '', pageRoute_1.OperatorType.DEFAULT, [''], pageRoute_1.TransitionType.PAGE, defaultNode.id, v.id));\n            }\n        }\n        for (const neighbour of neighbours) {\n            if (!neighbour.transitionDestiny)\n                continue;\n            const node = this.getNodeById(neighbour.transitionDestiny);\n            if (node && !visited.has(node)) {\n                // const haveFollowup = !!node.questions.find(q => q.followup);\n                const new_depth = depth + 1; // haveFollowup ? depth + 2 : depth + 1;\n                // Make a copy of the visited set to only for this branch\n                const visitedBranch = new Set(visited);\n                const dfs = this.DFSUtil(node, visitedBranch, new_depth);\n                max_depth = Math.max(max_depth, dfs);\n            }\n        }\n        return max_depth;\n    }\n    parseMatrixAnswer(ans) {\n        // ans.value puede ser:\n        // 1. Un array con un string JSON que representa la matriz\n        // 2. Un array de objetos ya parseados\n        // 3. Un array vaco\n        if (!ans || !ans.value)\n            return [];\n        // Caso 1: primer elemento es string con JSON de la matriz\n        if (ans.value.length === 1 && typeof ans.value[0] === 'string' && ans.value[0].trim().startsWith('[')) {\n            try {\n                const parsed = JSON.parse(ans.value[0]);\n                if (Array.isArray(parsed))\n                    return parsed;\n            }\n            catch (e) {\n                // Ignorar errores de parseo\n                return [];\n            }\n        }\n        // Caso 2: el array ya contiene objetos { key, value }\n        if (Array.isArray(ans.value) && ans.value.length > 0 && typeof ans.value[0] === 'object' && ans.value[0] !== null && 'key' in ans.value[0]) {\n            return ans.value;\n        }\n        return [];\n    }\n    evaluateMatrixCondition(edge, answerValue) {\n        const edgeVals = Array.isArray(edge.value) ? edge.value : [edge.value];\n        const optionFilter = new Set(edge.option || []); // eje X a filtrar\n        const ans = answerValue[0]; // Se asume una respuesta por pregunta\n        const rows = this.parseMatrixAnswer(ans);\n        if (!rows.length)\n            return false;\n        const relevantRows = optionFilter.size > 0 ? rows.filter(r => optionFilter.has(r.key)) : rows;\n        if (!relevantRows.length)\n            return false;\n        const intersects = (rowValues) => rowValues.some(v => edgeVals.includes(v));\n        const notIntersects = (rowValues) => rowValues.every(v => !edgeVals.includes(v));\n        switch (edge.typeOperator) {\n            case pageRoute_1.OperatorType.EQUAL:\n            // Todas las filas relevantes deben contener al menos un valor de edgeVals\n            // return relevantRows.every(r => intersects(Array.isArray(r.value) ? r.value : [r.value]));\n            case pageRoute_1.OperatorType.INQ:\n                // Alguna fila relevante contiene al menos un valor de edgeVals (se mantiene comportamiento original para INQ)\n                return relevantRows.some(r => intersects(Array.isArray(r.value) ? r.value : [r.value]));\n            case pageRoute_1.OperatorType.NOEQUAL:\n            case pageRoute_1.OperatorType.NINQ:\n                // Todas las filas relevantes NO contienen valores de edgeVals\n                return relevantRows.every(r => notIntersects(Array.isArray(r.value) ? r.value : [r.value]));\n            case pageRoute_1.OperatorType.GREATER:\n                return relevantRows.some(r => {\n                    const vals = Array.isArray(r.value) ? r.value : [r.value];\n                    return vals.some(val => edgeVals.some(edgeVal => Number(val) > Number(edgeVal)));\n                });\n            case pageRoute_1.OperatorType.LESS:\n                return relevantRows.some(r => {\n                    const vals = Array.isArray(r.value) ? r.value : [r.value];\n                    return vals.some(val => edgeVals.some(edgeVal => Number(val) < Number(edgeVal)));\n                });\n            case pageRoute_1.OperatorType.GREATEREQUAL:\n                return relevantRows.some(r => {\n                    const vals = Array.isArray(r.value) ? r.value : [r.value];\n                    return vals.some(val => edgeVals.some(edgeVal => Number(val) >= Number(edgeVal)));\n                });\n            case pageRoute_1.OperatorType.LESSEQUAL:\n                return relevantRows.some(r => {\n                    const vals = Array.isArray(r.value) ? r.value : [r.value];\n                    return vals.some(val => edgeVals.some(edgeVal => Number(val) <= Number(edgeVal)));\n                });\n            default:\n                return false;\n        }\n    }\n}\nexports.PageGraph = PageGraph;\n\n\n//# sourceURL=webpack://magicfeedback/./src/models/pageGrafs.ts?");

/***/ }),

/***/ "./src/models/pageNode.ts":
/*!********************************!*\
  !*** ./src/models/pageNode.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PageNode = void 0;\nclass PageNode {\n    constructor(id, position, edges, data, questions, isFollowup = false) {\n        this.answers = [];\n        this.id = id;\n        this.position = position;\n        this.edges = edges;\n        this.data = data;\n        this.questions = questions.sort((a, b) => a.position - b.position);\n        this.elements = [];\n        this.isFollowup = isFollowup;\n    }\n    /**\n     * Get a list of followup questions ref\n     * @returns list of followup questions ref\n     **/\n    getFollowupQuestions() {\n        return this.questions.filter(question => question.followup).map(question => question.ref);\n    }\n    /**\n     * Get a list of ref of the questions that are required in the page\n     * @returns ref of the required questions ref\n     **/\n    getRequiredQuestions() {\n        return this.questions.filter(question => question.require).map(question => question.ref);\n    }\n    /**\n     * Set the answer for a question\n     * @param questionRef\n     * @param answer\n     */\n    setAnswer(answer) {\n        this.answers = answer;\n    }\n}\nexports.PageNode = PageNode;\n\n\n//# sourceURL=webpack://magicfeedback/./src/models/pageNode.ts?");

/***/ }),

/***/ "./src/models/pageRoute.ts":
/*!*********************************!*\
  !*** ./src/models/pageRoute.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PageRoute = exports.StatusType = exports.OperatorType = exports.ConditionType = exports.TransitionType = void 0;\nvar TransitionType;\n(function (TransitionType) {\n    TransitionType[\"PAGE\"] = \"PAGE\";\n    TransitionType[\"FINISH\"] = \"FINISH\";\n    TransitionType[\"REDIRECT\"] = \"REDIRECT\";\n    TransitionType[\"NEXT\"] = \"NEXT\";\n    TransitionType[\"ALLOW\"] = \"ALLOW\";\n})(TransitionType = exports.TransitionType || (exports.TransitionType = {}));\nvar ConditionType;\n(function (ConditionType) {\n    ConditionType[\"LOGICAL\"] = \"LOGICAL\";\n    ConditionType[\"DIRECT\"] = \"DIRECT\";\n    ConditionType[\"PRECONDITIONAL\"] = \"PRECONDITIONAL\";\n})(ConditionType = exports.ConditionType || (exports.ConditionType = {}));\nvar OperatorType;\n(function (OperatorType) {\n    OperatorType[\"EQUAL\"] = \"EQUAL\";\n    OperatorType[\"NOEQUAL\"] = \"NOEQUAL\";\n    OperatorType[\"GREATER\"] = \"GREATER\";\n    OperatorType[\"LESS\"] = \"LESS\";\n    OperatorType[\"GREATEREQUAL\"] = \"GREATEREQUAL\";\n    OperatorType[\"LESSEQUAL\"] = \"LESSEQUAL\";\n    OperatorType[\"INQ\"] = \"INQ\";\n    OperatorType[\"NINQ\"] = \"NINQ\";\n    OperatorType[\"DEFAULT\"] = \"DEFAULT\";\n})(OperatorType = exports.OperatorType || (exports.OperatorType = {}));\nvar StatusType;\n(function (StatusType) {\n    StatusType[\"ACTIVE\"] = \"ACTIVE\";\n    StatusType[\"DEPRECATED\"] = \"DEPRECATED\";\n    StatusType[\"DELETE\"] = \"DELETE\";\n})(StatusType = exports.StatusType || (exports.StatusType = {}));\nclass PageRoute {\n    constructor(id, questionRef, typeOperator, value, transition, transitionDestiny, integrationPageId, typeCondition, position, option) {\n        this.id = id;\n        this.questionRef = questionRef;\n        this.typeCondition = typeCondition || ConditionType.LOGICAL;\n        this.typeOperator = typeOperator;\n        this.value = value || [];\n        this.transition = transition;\n        this.transitionDestiny = transitionDestiny;\n        this.status = StatusType.ACTIVE;\n        this.generatedAt = new Date();\n        this.updatedAt = new Date();\n        this.integrationPageId = integrationPageId;\n        this.position = position || 0;\n        this.option = option || [];\n    }\n}\nexports.PageRoute = PageRoute;\n\n\n//# sourceURL=webpack://magicfeedback/./src/models/pageRoute.ts?");

/***/ }),

/***/ "./src/models/types.ts":
/*!*****************************!*\
  !*** ./src/models/types.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QuestionType = exports.FEEDBACKAPPANSWERTYPE = void 0;\nvar FEEDBACKAPPANSWERTYPE;\n(function (FEEDBACKAPPANSWERTYPE) {\n    FEEDBACKAPPANSWERTYPE[\"CONTACT\"] = \"CONTACT\";\n    FEEDBACKAPPANSWERTYPE[\"MULTIPLECHOISE_IMAGE\"] = \"MULTIPLECHOISE_IMAGE\";\n    FEEDBACKAPPANSWERTYPE[\"EMAIL\"] = \"EMAIL\";\n    FEEDBACKAPPANSWERTYPE[\"RATING_STAR\"] = \"RATING_STAR\";\n    FEEDBACKAPPANSWERTYPE[\"RADIO\"] = \"RADIO\";\n    FEEDBACKAPPANSWERTYPE[\"MULTIPLECHOICE\"] = \"MULTIPLECHOICE\";\n    FEEDBACKAPPANSWERTYPE[\"SELECT\"] = \"SELECT\";\n    FEEDBACKAPPANSWERTYPE[\"TEXT\"] = \"TEXT\";\n    FEEDBACKAPPANSWERTYPE[\"LONGTEXT\"] = \"LONGTEXT\";\n    FEEDBACKAPPANSWERTYPE[\"NUMBER\"] = \"NUMBER\";\n    FEEDBACKAPPANSWERTYPE[\"RATING_EMOJI\"] = \"RATING_EMOJI\";\n    FEEDBACKAPPANSWERTYPE[\"RATING_NUMBER\"] = \"RATING_NUMBER\";\n    FEEDBACKAPPANSWERTYPE[\"DATE\"] = \"DATE\";\n    FEEDBACKAPPANSWERTYPE[\"BOOLEAN\"] = \"BOOLEAN\";\n    FEEDBACKAPPANSWERTYPE[\"PASSWORD\"] = \"PASSWORD\";\n    FEEDBACKAPPANSWERTYPE[\"CONSENT\"] = \"CONSENT\";\n    FEEDBACKAPPANSWERTYPE[\"MULTI_QUESTION_MATRIX\"] = \"MULTI_QUESTION_MATRIX\";\n    FEEDBACKAPPANSWERTYPE[\"POINT_SYSTEM\"] = \"POINT_SYSTEM\";\n    FEEDBACKAPPANSWERTYPE[\"PRIORITY_LIST\"] = \"PRIORITY_LIST\";\n    FEEDBACKAPPANSWERTYPE[\"INFO_PAGE\"] = \"INFO_PAGE\";\n    FEEDBACKAPPANSWERTYPE[\"UPLOAD_FILE\"] = \"UPLOAD_FILE\";\n    FEEDBACKAPPANSWERTYPE[\"UPLOAD_IMAGE\"] = \"UPLOAD_IMAGE\";\n})(FEEDBACKAPPANSWERTYPE = exports.FEEDBACKAPPANSWERTYPE || (exports.FEEDBACKAPPANSWERTYPE = {}));\nclass QuestionType {\n}\nexports.QuestionType = QuestionType;\nvar generateFormOptionsTag;\n(function (generateFormOptionsTag) {\n    generateFormOptionsTag[\"FORM\"] = \"form\";\n    generateFormOptionsTag[\"DIV\"] = \"div\";\n})(generateFormOptionsTag || (generateFormOptionsTag = {}));\n\n\n//# sourceURL=webpack://magicfeedback/./src/models/types.ts?");

/***/ }),

/***/ "./src/services/paths.ts":
/*!*******************************!*\
  !*** ./src/services/paths.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.endpoints = void 0;\nexports.endpoints = {\n    sdk: {\n        app: (appId, publicKey) => `sdk/app/${appId}/${publicKey}`,\n        app_info: (appId, publicKey) => `sdk/app/${appId}/${publicKey}/info`,\n        session: (sessionId) => `sdk/app/session/${sessionId}/info`,\n        feedback: 'sdk/feedback',\n        followUpQuestion: 'sdk/followUpQuestion',\n    }\n};\n\n\n//# sourceURL=webpack://magicfeedback/./src/services/paths.ts?");

/***/ }),

/***/ "./src/services/placeholder.ts":
/*!*************************************!*\
  !*** ./src/services/placeholder.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.placeholder = void 0;\nexports.placeholder = {\n    answer: (language) => {\n        switch (language) {\n            case \"en\":\n                return \"Write your answer here...\";\n            case \"es\":\n                return \"Escribe tu respuesta aqu...\";\n            case 'da':\n                return 'Skriv dit svar her...';\n            case 'fi':\n                return 'Kirjoita vastauksesi thn...';\n            case 'sv':\n                return 'Skriv ditt svar hr...';\n            case 'no':\n                return 'Skriv svaret ditt her...';\n            case 'ar':\n                return '  ...';\n            case 'bn':\n                return ' ';\n            default:\n                return \"Write your answer here...\";\n        }\n    },\n    number: (language) => {\n        switch (language) {\n            case \"en\":\n                return \"Write your number here...\";\n            case \"es\":\n                return \"Escribe tu nmero aqu...\";\n            case 'da':\n                return 'Skriv dit nummer her...';\n            case 'fi':\n                return 'Kirjoita numerosi thn...';\n            case 'sv':\n                return 'Skriv ditt nummer hr...';\n            case 'no':\n                return 'Skriv nummeret ditt her...';\n            case 'ar':\n                return '  ...';\n            case 'bn':\n                return ' ';\n            default:\n                return \"Write your number here...\";\n        }\n    },\n    email: (language) => {\n        switch (language) {\n            case \"en\":\n                return \"Write your email here...\";\n            case \"es\":\n                return \"Escribe tu correo electrnico aqu...\";\n            case 'da':\n                return 'Skriv din e-mail her...';\n            case 'fi':\n                return 'Kirjoita shkpostiosoitteesi thn...';\n            case 'sv':\n                return 'Skriv din e-post hr...';\n            case 'no':\n                return 'Skriv e-posten din her...';\n            case 'ar':\n                return '   ...';\n            case 'bn':\n                return ' ';\n            default:\n                return \"Write your email here...\";\n        }\n    },\n    date: (language) => {\n        switch (language) {\n            case \"en\":\n                return \"Write your date here...\";\n            case \"es\":\n                return \"Escribe tu fecha aqu...\";\n            case 'da':\n                return 'Skriv din dato her...';\n            case 'fi':\n                return 'Kirjoita pivmrsi thn...';\n            case 'sv':\n                return 'Skriv ditt datum hr...';\n            case 'no':\n                return 'Skriv datoen din her...';\n            case 'ar':\n                return '  ...';\n            case 'bn':\n                return ' ';\n            default:\n                return \"Write your date here...\";\n        }\n    },\n    password: (language) => {\n        switch (language) {\n            case \"en\":\n                return \"Write your password here...\";\n            case \"es\":\n                return \"Escribe tu contrasea aqu...\";\n            case 'da':\n                return 'Skriv dit kodeord her...';\n            case 'fi':\n                return 'Kirjoita salasanasi thn...';\n            case 'sv':\n                return 'Skriv ditt lsenord hr...';\n            case 'no':\n                return 'Skriv passordet ditt her...';\n            case 'ar':\n                return '     ...';\n            case 'bn':\n                return ' ';\n            default:\n                return \"Write your password here...\";\n        }\n    },\n    pointsystemerror: (language) => {\n        switch (language) {\n            case \"en\":\n                return \"The total points must be 100 %\";\n            case \"es\":\n                return \"El total de puntos debe ser 100 %\";\n            case 'da':\n                return 'Samlet antal point skal vre 100 %';\n            case 'fi':\n                return 'Kokonaispisteiden on oltava 100 %';\n            case 'sv':\n                return 'Totala pong mste vara 100 %';\n            case 'no':\n                return 'Totalt antall poeng m vre 100 %';\n            case 'ar':\n                return '     100 %';\n            case 'bn':\n                return '  100 %  ';\n            default:\n                return \"The total points must be 100 %\";\n        }\n    }\n};\n\n\n//# sourceURL=webpack://magicfeedback/./src/services/placeholder.ts?");

/***/ }),

/***/ "./src/services/questions.service.ts":
/*!*******************************************!*\
  !*** ./src/services/questions.service.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.renderStartMessage = exports.renderSuccess = exports.renderError = exports.renderActions = exports.renderQuestions = void 0;\nconst types_1 = __webpack_require__(/*! ../models/types */ \"./src/models/types.ts\");\nconst placeholder_1 = __webpack_require__(/*! ./placeholder */ \"./src/services/placeholder.ts\");\n// Function to get the query params\nconst params = (a) => {\n    const searchParams = new URLSearchParams(window.location.search);\n    return searchParams.get(a);\n};\nconst defaultUrl = `https://survey-dev.magicfeedback.io/assets/emojis`;\nfunction renderQuestions(appQuestions, format = \"standard\", language = \"en\", product = { customIcons: false }, send) {\n    if (!appQuestions)\n        throw new Error(\"[MagicFeedback] No questions provided\");\n    const questions = [];\n    const { customIcons, id } = product;\n    appQuestions.forEach((question) => {\n        var _a, _b;\n        if (((_b = (_a = question === null || question === void 0 ? void 0 : question.questionType) === null || _a === void 0 ? void 0 : _a.conf) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n            let elementContainer = document.createElement(\"div\");\n            elementContainer.classList.add(\"magicfeedback-div\");\n            const label = document.createElement(\"label\");\n            label.setAttribute(\"for\", `magicfeedback-${question.id}`);\n            label.textContent = parseTitle(question.title, language);\n            label.classList.add(\"magicfeedback-label\");\n            elementContainer.appendChild(label);\n            question.questionType.conf.forEach((conf) => {\n                conf.ref = question.ref;\n                if (question.assets[conf.id]) {\n                    conf.assets = {\n                        placeholder: question.assets[conf.id],\n                    };\n                }\n            });\n            const elements = renderQuestions(question.questionType.conf, format, language, product, send);\n            elements.forEach((element) => {\n                elementContainer.appendChild(element);\n            });\n            questions.push(elementContainer);\n        }\n        else {\n            // Create a container for each question\n            const url = `${defaultUrl}${customIcons ? `/${id}` : ''}`;\n            const elementContainer = renderContainer(question, format, language, url, appQuestions.length === 1 ? send : undefined);\n            questions.push(elementContainer);\n        }\n    });\n    return questions;\n}\nexports.renderQuestions = renderQuestions;\nfunction parseTitle(title, lang) {\n    if (!title)\n        return '';\n    return typeof title === \"object\" ? (title[lang] || title['en']) : title;\n}\n// Make a function to return a array with yes and no in every language\nfunction getBooleanOptions(lang) {\n    switch (lang) {\n        case \"es\":\n            return ['S', 'No'];\n        case \"fr\":\n            return ['Oui', 'Non'];\n        case \"de\":\n            return ['Ja', 'Nein'];\n        case \"it\":\n            return ['S', 'No'];\n        case \"pt\":\n            return ['Sim', 'No'];\n        case \"nl\":\n            return ['Ja', 'Nee'];\n        case \"pl\":\n            return ['Tak', 'Nie'];\n        case \"ru\":\n            return ['', ''];\n        case \"ja\":\n            return ['', ''];\n        case \"zh\":\n            return ['', ''];\n        case \"ko\":\n            return ['', ''];\n        case 'da':\n            return ['Ja', 'Nej'];\n        case 'fi':\n            return ['Kyll', 'Ei'];\n        case 'sv':\n            return ['Ja', 'Nej'];\n        case 'no':\n            return ['Ja', 'Nei'];\n        case 'ar':\n            return ['', ''];\n        case 'bn':\n            return ['', ''];\n        default:\n            return ['Yes', 'No'];\n    }\n}\nfunction renderContainer(question, format, language, url, send) {\n    var _a, _b, _c;\n    let { id, title, type, ref, require, \n    //external_id,\n    value, defaultValue, \n    // questionType,\n    assets } = question;\n    let element;\n    let elementTypeClass;\n    let elementContainer = document.createElement(\"div\");\n    elementContainer.classList.add(\"magicfeedback-div\");\n    const isPhone = window.innerWidth < 600;\n    const placeholderText = format === 'slim' ? parseTitle(title, language) : assets === null || assets === void 0 ? void 0 : assets.placeholder;\n    // Look if exist the value in a query param with the ref like a key\n    const urlParamValue = params(ref);\n    const maxCharacters = (assets === null || assets === void 0 ? void 0 : assets.maxCharacters) || 0;\n    const randomPosition = (assets === null || assets === void 0 ? void 0 : assets.randomPosition) === undefined ? false : assets === null || assets === void 0 ? void 0 : assets.randomPosition;\n    const direction = (assets === null || assets === void 0 ? void 0 : assets.direction) || \"row\";\n    const order = (assets === null || assets === void 0 ? void 0 : assets.order) || \"ltr\";\n    switch (type) {\n        case types_1.FEEDBACKAPPANSWERTYPE.TEXT:\n            // Create a text input field\n            element = document.createElement(\"input\");\n            element.type = \"text\";\n            element.placeholder = placeholderText || placeholder_1.placeholder.answer(language || 'en');\n            if (urlParamValue) {\n                element.value = urlParamValue;\n            }\n            // Control on press enter\n            element.addEventListener(\"keyup\", (event) => {\n                event.preventDefault();\n                console.log(event.key, event);\n                if (event.key === \"Enter\") {\n                    if (send)\n                        send();\n                }\n            });\n            elementTypeClass = \"magicfeedback-text\";\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.LONGTEXT:\n            // Create a textarea element for TEXT and LONGTEXT types\n            element = document.createElement(\"textarea\");\n            element.rows = 3; // Set the number of rows based on the type\n            if (maxCharacters > 0)\n                element.maxLength = maxCharacters; // Set the max length of the text area\n            element.placeholder = placeholderText || placeholder_1.placeholder.answer(language || 'en');\n            if (urlParamValue) {\n                element.value = urlParamValue;\n            }\n            elementTypeClass = \"magicfeedback-longtext\";\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.NUMBER:\n            // Create an input element with type \"number\" for NUMBER type\n            element = document.createElement(\"input\");\n            element.type = \"number\";\n            element.placeholder = format === 'slim' ? parseTitle(title, language) : placeholder_1.placeholder.number(language || 'en');\n            elementTypeClass = \"magicfeedback-number\";\n            if (value.length) {\n                value.sort((a, b) => Number(a) - Number(b));\n                element.max = value[value.length - 1];\n                element.min = value[0];\n                element.value = value[0];\n            }\n            if (urlParamValue && !isNaN(Number(urlParamValue))) {\n                element.value = urlParamValue;\n            }\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.RADIO:\n        case types_1.FEEDBACKAPPANSWERTYPE.MULTIPLECHOICE:\n            element = document.createElement(\"div\");\n            elementTypeClass =\n                `magicfeedback-${(type === \"MULTIPLECHOICE\" ? \"checkbox\" : \"radio\")}`;\n            let opt = value || [];\n            // reorder the options if randomPosition is true\n            if (randomPosition) {\n                opt = opt.sort(() => Math.random() - 0.5);\n            }\n            let exclusiveAnswers = (assets === null || assets === void 0 ? void 0 : assets.exclusiveAnswers) || [];\n            // Fix: excluir la opcin extraOptionText de la lista de exclusivas si por error viene incluida desde backend/state\n            if (assets === null || assets === void 0 ? void 0 : assets.extraOption) {\n                exclusiveAnswers = exclusiveAnswers.filter(a => a !== assets.extraOptionText);\n            }\n            if (exclusiveAnswers.length > 0) {\n                exclusiveAnswers === null || exclusiveAnswers === void 0 ? void 0 : exclusiveAnswers.forEach((answer) => {\n                    if (!opt.includes(answer))\n                        opt.push(answer);\n                });\n            }\n            if ((assets === null || assets === void 0 ? void 0 : assets.extraOption) && !opt.includes(assets === null || assets === void 0 ? void 0 : assets.extraOptionText)) {\n                opt.push(assets === null || assets === void 0 ? void 0 : assets.extraOptionText);\n            }\n            opt.forEach((option, index) => {\n                const container = document.createElement(\"div\");\n                container.classList.add(`magicfeedback-${type === \"MULTIPLECHOICE\" ? \"checkbox\" : \"radio\"}-container`);\n                const label = document.createElement(\"label\");\n                const input = document.createElement(\"input\");\n                input.id = `rating-${ref}-${index}`;\n                input.type = type === \"MULTIPLECHOICE\" ? \"checkbox\" : \"radio\";\n                input.name = ref;\n                input.value = option;\n                input.classList.add(elementTypeClass);\n                input.classList.add(\"magicfeedback-input\");\n                if (type === types_1.FEEDBACKAPPANSWERTYPE.MULTIPLECHOICE && (assets === null || assets === void 0 ? void 0 : assets.maxOptions) && (assets === null || assets === void 0 ? void 0 : assets.maxOptions) > 0) {\n                    input.addEventListener(\"change\", () => {\n                        const checkboxes = document.querySelectorAll(`input[name=\"${ref}\"]:checked`);\n                        if (checkboxes.length > (assets === null || assets === void 0 ? void 0 : assets.maxOptions)) {\n                            input.checked = false;\n                        }\n                        //TODO: Enable in the future with a setting variable to send the answer when reach the max options selected\n                        /**\n                         if (send && checkboxes.length === assets?.maxOptions && !(assets?.extraOptionText && option === assets?.extraOptionText)) {\n                         send()\n                         }\n                         **/\n                    });\n                }\n                if (type === types_1.FEEDBACKAPPANSWERTYPE.RADIO && send) {\n                    if (!(assets === null || assets === void 0 ? void 0 : assets.extraOptionText) || (assets === null || assets === void 0 ? void 0 : assets.extraOptionText) && option !== (assets === null || assets === void 0 ? void 0 : assets.extraOptionText))\n                        input.addEventListener(\"change\", () => {\n                            send();\n                        });\n                }\n                if (option === defaultValue || option === urlParamValue) {\n                    input.checked = true;\n                }\n                label.textContent = option;\n                label.htmlFor = `rating-${ref}-${index}`;\n                input.addEventListener(\"change\", (event) => {\n                    const extraOption = document.getElementById(`extra-option-${ref}`);\n                    if (event.target.checked && exclusiveAnswers.includes(option)) {\n                        console.log('exclusiveAnswers', exclusiveAnswers, option);\n                        opt.forEach((answer) => {\n                            if (answer !== option) {\n                                const input = document.querySelector(`input[value=\"${answer}\"]`);\n                                input.checked = false;\n                            }\n                        });\n                        if (extraOption)\n                            extraOption.style.display = \"none\";\n                    }\n                    else {\n                        // Remove the checke of the exclusiveAnswers\n                        exclusiveAnswers.forEach((answer) => {\n                            if (answer !== option) {\n                                const input = document.querySelector(`input[value=\"${answer}\"]`);\n                                input.checked = false;\n                            }\n                        });\n                        // if (extraOption) extraOption.style.display = assets?.extraOption && option === assets?.extraOptionText ? \"block\" : \"none\";\n                    }\n                    if ((assets === null || assets === void 0 ? void 0 : assets.extraOption) && option === (assets === null || assets === void 0 ? void 0 : assets.extraOptionText) && extraOption)\n                        // SI al opcion con value assets?.extraOptionText esta seleccionada mostrar el input text si no ocultarlo\n                        extraOption.style.display = event.target.checked ? \"block\" : \"none\";\n                });\n                container.appendChild(input);\n                container.appendChild(label);\n                element.appendChild(container);\n                // If is assets.extraOptionText add a input text after the label to add a custom value available only if is selected\n                if ((assets === null || assets === void 0 ? void 0 : assets.extraOption) && option === (assets === null || assets === void 0 ? void 0 : assets.extraOptionText)) {\n                    const inputText = document.createElement(\"input\");\n                    inputText.type = \"text\";\n                    inputText.placeholder = (assets === null || assets === void 0 ? void 0 : assets.extraOptionPlaceholder) || placeholder_1.placeholder.answer(language || 'en');\n                    inputText.classList.add(\"magicfeedback-extra-option\");\n                    inputText.classList.add(\"magicfeedback-input\");\n                    inputText.id = `extra-option-${ref}`;\n                    inputText.name = `extra-option-${ref}`;\n                    inputText.style.display = \"none\";\n                    element.appendChild(inputText);\n                }\n            });\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.BOOLEAN:\n            // Create an input element with type \"checkbox\" for BOOLEAN type with option yes or no\n            element = document.createElement(\"div\");\n            elementTypeClass = 'magicfeedback-radio';\n            const booleanContainer = document.createElement('div');\n            booleanContainer.classList.add('magicfeedback-boolean-container');\n            booleanContainer.style.display = \"flex\";\n            booleanContainer.style.flexDirection = \"row\";\n            booleanContainer.style.justifyContent = \"space-between\";\n            booleanContainer.style.width = \"70%\";\n            booleanContainer.style.margin = \"auto\";\n            const booleanOptions = (assets === null || assets === void 0 ? void 0 : assets.addIcon) ? ['', ''] : getBooleanOptions(language);\n            // Create a input button element for each value in the question's value array\n            booleanOptions.forEach((option, index) => {\n                const container = document.createElement(\"label\");\n                container.classList.add(\"magicfeedback-boolean-option\");\n                container.htmlFor = `rating-${ref}-${index}`;\n                container.style.cursor = \"pointer\";\n                container.style.border = \"1px solid #000\";\n                container.style.display = \"flex\";\n                container.style.justifyContent = \"center\";\n                container.style.alignItems = \"center\";\n                container.style.margin = \"auto\";\n                container.style.padding = \"0\";\n                container.style.width = \"45%\";\n                container.style.height = \"38px\";\n                const label = document.createElement(\"label\");\n                label.htmlFor = `rating-${ref}-${index}`;\n                label.textContent = option;\n                label.style.margin = \"0\";\n                label.style.padding = \"0\";\n                const input = document.createElement(\"input\");\n                input.id = `rating-${ref}-${index}`;\n                input.type = \"radio\";\n                input.name = ref;\n                input.value = ['Yes', 'No'][index];\n                input.classList.add(elementTypeClass);\n                input.classList.add(\"magicfeedback-input\");\n                input.style.position = \"absolute\";\n                input.style.opacity = \"0\";\n                input.style.width = \"0\";\n                input.style.height = \"0\";\n                input.style.margin = \"0\";\n                input.addEventListener(\"change\", () => {\n                    if (send)\n                        send();\n                });\n                if (urlParamValue && urlParamValue.toLowerCase() === input.value.toLowerCase()) {\n                    input.checked = true;\n                }\n                container.appendChild(input);\n                container.appendChild(label);\n                booleanContainer.appendChild(container);\n            });\n            element.appendChild(booleanContainer);\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.RATING_EMOJI:\n            element = document.createElement(\"div\");\n            elementTypeClass = 'magicfeedback-rating';\n            const ratingContainer = document.createElement('div');\n            ratingContainer.classList.add('magicfeedback-rating-container');\n            const maxRating = (assets === null || assets === void 0 ? void 0 : assets.max) ? Number(assets === null || assets === void 0 ? void 0 : assets.max) : 5;\n            const minRating = (assets === null || assets === void 0 ? void 0 : assets.min) ? Number(assets === null || assets === void 0 ? void 0 : assets.min) : 1;\n            const ratingPlaceholder = createRatingPlaceholder(minRating, maxRating, assets === null || assets === void 0 ? void 0 : assets.minPlaceholder, assets === null || assets === void 0 ? void 0 : assets.maxPlaceholder, assets === null || assets === void 0 ? void 0 : assets.extraOption);\n            for (let i = minRating; i <= maxRating; i++) {\n                const ratingOption = document.createElement('div');\n                ratingOption.classList.add('magicfeedback-rating-option');\n                const containerLabel = document.createElement('label');\n                containerLabel.htmlFor = `rating-${ref}-${i}`;\n                containerLabel.classList.add('magicfeedback-rating-option-label-container');\n                const ratingLabel = document.createElement('label');\n                ratingLabel.htmlFor = `rating-${ref}-${i}`;\n                ratingLabel.textContent = i.toString();\n                const ratingImage = document.createElement('img');\n                ratingImage.alt = `face-${ref}-${i}`;\n                ratingImage.className = `rating-image${i}`;\n                if (minRating === 0 && maxRating === 10) {\n                    ratingImage.src = `${url}/${i}.svg`;\n                    ratingImage.onerror = () => ratingImage.src = `${defaultUrl}/${i}.svg`;\n                }\n                else if (minRating === 1 && maxRating === 5) {\n                    switch (i) {\n                        case 1:\n                            ratingImage.src = `${url}/1.svg`;\n                            ratingImage.onerror = () => ratingImage.src = `${defaultUrl}/1.svg`;\n                            break;\n                        case 2:\n                            ratingImage.src = `${url}/2.svg`;\n                            ratingImage.onerror = () => ratingImage.src = `${defaultUrl}/2.svg`;\n                            break;\n                        case 3:\n                            ratingImage.src = `${url}/6.svg`;\n                            ratingImage.onerror = () => ratingImage.src = `${defaultUrl}/6.svg`;\n                            break;\n                        case 4:\n                            ratingImage.src = `${url}/9.svg`;\n                            ratingImage.onerror = () => ratingImage.src = `${defaultUrl}/9.svg`;\n                            break;\n                        case 5:\n                            ratingImage.src = `${url}/10.svg`;\n                            ratingImage.onerror = () => ratingImage.src = `${defaultUrl}/10.svg`;\n                            break;\n                    }\n                }\n                else {\n                    const ratingNum = Math.round((i - minRating) * (10 / (maxRating - minRating)));\n                    ratingImage.src = `${url}/${ratingNum}.svg`;\n                    ratingImage.onerror = () => ratingImage.src = `${defaultUrl}/${ratingNum}.svg`;\n                }\n                const input = document.createElement(\"input\");\n                input.id = `rating-${ref}-${i}`;\n                input.type = \"radio\";\n                input.name = ref;\n                input.value = i.toString();\n                input.classList.add(elementTypeClass);\n                input.classList.add(\"magicfeedback-input\");\n                if (send) {\n                    input.addEventListener(\"change\", () => {\n                        send();\n                    });\n                }\n                if (urlParamValue && urlParamValue === input.value) {\n                    input.checked = true;\n                }\n                containerLabel.appendChild(input);\n                containerLabel.appendChild(ratingImage);\n                containerLabel.appendChild(ratingLabel);\n                ratingOption.appendChild(containerLabel);\n                ratingContainer.appendChild(ratingOption);\n            }\n            if ((assets === null || assets === void 0 ? void 0 : assets.extraOption) && (assets === null || assets === void 0 ? void 0 : assets.extraOptionText)) {\n                const extraOption = document.createElement('div');\n                extraOption.classList.add('magicfeedback-rating-option');\n                const containerLabel = document.createElement('label');\n                containerLabel.htmlFor = `rating-${ref}-extra`;\n                containerLabel.classList.add('magicfeedback-rating-option-label-container');\n                const ratingLabel = document.createElement('label');\n                ratingLabel.htmlFor = `rating-${ref}-extra`;\n                ratingLabel.textContent = assets === null || assets === void 0 ? void 0 : assets.extraOptionText;\n                // Add a question mark icon to the extra option\n                const ratingImage = document.createElement('img');\n                ratingImage.src = \"https://magicfeedback-c6458-dev.web.app/assets/question.svg\";\n                ratingImage.alt = `face-${ref}-extra`;\n                ratingImage.className = `magicfeedback-rating-image-extra`;\n                const input = document.createElement(\"input\");\n                input.id = `rating-${ref}-extra`;\n                input.type = \"radio\";\n                input.name = ref;\n                input.value = '-';\n                input.classList.add(elementTypeClass);\n                input.classList.add(\"magicfeedback-input\");\n                if (send) {\n                    input.addEventListener(\"change\", () => {\n                        send();\n                    });\n                }\n                containerLabel.appendChild(input);\n                containerLabel.appendChild(ratingImage);\n                containerLabel.appendChild(ratingLabel);\n                extraOption.appendChild(containerLabel);\n                ratingContainer.appendChild(extraOption);\n            }\n            element.appendChild(ratingPlaceholder);\n            element.appendChild(ratingContainer);\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.RATING_NUMBER:\n            elementTypeClass = 'magicfeedback-rating-number';\n            element = createRatingNumberElement(ref, assets, order, direction, isPhone, elementTypeClass, send, urlParamValue);\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.RATING_STAR:\n            element = document.createElement(\"div\");\n            elementTypeClass = 'magicfeedback-rating-star';\n            const ratingStarContainer = createStarRating(ref, assets === null || assets === void 0 ? void 0 : assets.minPlaceholder, assets === null || assets === void 0 ? void 0 : assets.maxPlaceholder, send, urlParamValue);\n            element.appendChild(ratingStarContainer);\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.MULTIPLECHOISE_IMAGE:\n            element = document.createElement(\"div\");\n            elementTypeClass = 'magicfeedback-multiple-choice-image';\n            // Display de items inside a flex container if only have one item display it as a single image in the center, if have 2 items display them as a row, if have more than 2 items display them as a grid, if have 4 items display them as a 2x2 grid and if have 6 items display them as a 3x2 grid\n            const multipleChoiceImageContainer = document.createElement(\"div\");\n            multipleChoiceImageContainer.classList.add(\"magicfeedback-multiple-choice-image-container\");\n            multipleChoiceImageContainer.style.display = \"flex\";\n            multipleChoiceImageContainer.style.flexDirection = \"row\";\n            multipleChoiceImageContainer.style.flexWrap = \"wrap\";\n            multipleChoiceImageContainer.style.justifyContent = \"center\";\n            const maxItems = value.length;\n            let itemsPerRow = 1;\n            let itemsPerColumn = 1;\n            if (window.innerWidth < 600) {\n                itemsPerRow = 1;\n                itemsPerColumn = maxItems;\n            }\n            else {\n                switch (maxItems) {\n                    case 1:\n                    case 2:\n                    case 3:\n                        itemsPerRow = maxItems;\n                        itemsPerColumn = 1;\n                        break;\n                    case 4:\n                    case 5:\n                    case 6:\n                        itemsPerColumn = 2;\n                        itemsPerRow = Math.ceil(maxItems / itemsPerColumn);\n                        break;\n                    case 7:\n                    case 8:\n                    case 9:\n                        itemsPerColumn = 3;\n                        itemsPerRow = Math.ceil(maxItems / itemsPerColumn);\n                        break;\n                    default:\n                        itemsPerColumn = 4;\n                        itemsPerRow = Math.ceil(maxItems / itemsPerColumn);\n                        break;\n                }\n            }\n            const useLabel = (assets === null || assets === void 0 ? void 0 : assets.addTitle) === undefined ? false : assets === null || assets === void 0 ? void 0 : assets.addTitle;\n            const multiOptions = (assets === null || assets === void 0 ? void 0 : assets.multiOption) === undefined ? false : assets === null || assets === void 0 ? void 0 : assets.multiOption;\n            const extraOption = (assets === null || assets === void 0 ? void 0 : assets.extraOption) === undefined ? false : assets === null || assets === void 0 ? void 0 : assets.extraOption;\n            // reorder the options if randomPosition is true\n            if (randomPosition) {\n                value = value.sort(() => Math.random() - 0.5);\n            }\n            function generateOption(option) {\n                try {\n                    const { position, url, value } = option;\n                    const container = document.createElement(\"label\");\n                    container.classList.add(\"magicfeedback-multiple-choice-image-option\");\n                    container.style.width = `calc( ${100 / itemsPerRow}% - 10px)`;\n                    container.style.height = `calc( ${100 / itemsPerColumn}% - 10px)`;\n                    container.style.margin = \"5px\";\n                    const containerLabel = document.createElement('label');\n                    containerLabel.htmlFor = `rating-${ref}-${position}`;\n                    containerLabel.classList.add('magicfeedback-image-option-label-container');\n                    containerLabel.style.display = \"flex\";\n                    containerLabel.style.flexDirection = \"column\";\n                    // Add a effect on hover and on select\n                    containerLabel.addEventListener(\"mouseover\", () => {\n                        containerLabel.style.border = \"2px solid #000\";\n                    });\n                    containerLabel.addEventListener(\"mouseout\", () => {\n                        containerLabel.style.border = \"none\";\n                    });\n                    containerLabel.addEventListener(\"click\", () => {\n                        containerLabel.style.border = \"2px solid #000\";\n                    });\n                    const label = document.createElement(\"label\");\n                    label.textContent = value;\n                    label.classList.add(\"magicfeedback-multiple-choice-image-label\");\n                    const input = document.createElement(\"input\");\n                    input.id = `rating-${ref}-${position}`;\n                    input.type = multiOptions ? \"checkbox\" : \"radio\";\n                    input.name = ref;\n                    input.value = value;\n                    input.style.position = \"absolute\";\n                    input.style.opacity = \"0\";\n                    input.style.width = \"0\";\n                    input.style.height = \"0\";\n                    input.classList.add(\"magicfeedback-input\");\n                    if (urlParamValue && urlParamValue === input.value) {\n                        input.checked = true;\n                    }\n                    if (!multiOptions && send) {\n                        input.addEventListener(\"change\", () => {\n                            console.log('send');\n                            send();\n                        });\n                    }\n                    // Add max size to the image\n                    const image = document.createElement(\"img\");\n                    image.classList.add(\"magicfeedback-multiple-choice-image-image\");\n                    image.src = url;\n                    image.style.cursor = \"pointer\";\n                    image.style.backgroundSize = \"cover\";\n                    image.style.backgroundPosition = \"center\";\n                    image.style.width = \"100%\";\n                    image.style.height = \"100%\";\n                    image.style.objectFit = \"cover\";\n                    image.style.margin = \"auto\";\n                    containerLabel.appendChild(input);\n                    containerLabel.appendChild(image);\n                    if (useLabel)\n                        containerLabel.appendChild(label);\n                    container.appendChild(containerLabel);\n                    multipleChoiceImageContainer.appendChild(container);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n            // The image is the only input but can have a title\n            value.forEach((option) => generateOption(JSON.parse(option)));\n            if (extraOption && (assets === null || assets === void 0 ? void 0 : assets.extraOptionValue) && (assets === null || assets === void 0 ? void 0 : assets.extraOptionValue.length) > 0) {\n                generateOption(assets === null || assets === void 0 ? void 0 : assets.extraOptionValue[0]);\n            }\n            element.appendChild(multipleChoiceImageContainer);\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.SELECT:\n            // Create a select element for RADIO and MULTIPLECHOICE types\n            element = document.createElement(\"select\");\n            elementTypeClass = \"magicfeedback-select\";\n            // Create an option <option value=\"\" disabled selected hidden>Please Choose...</option>\n            const option = document.createElement(\"option\");\n            option.value = \"\";\n            option.text = format === 'slim' ? parseTitle(title, language) : (defaultValue || \"Select an option\");\n            option.disabled = true;\n            option.selected = true;\n            element.appendChild(option);\n            value.forEach((optionValue) => {\n                // Create an option element for each value in the question's value array\n                const option = document.createElement(\"option\");\n                option.value = optionValue;\n                option.text = optionValue;\n                element.appendChild(option);\n            });\n            if (urlParamValue && value.includes(urlParamValue)) {\n                element.value = urlParamValue;\n            }\n            if (send) {\n                element.addEventListener(\"change\", () => {\n                    send();\n                });\n            }\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.DATE:\n            // Create an input element with type \"date\" for DATE type\n            element = document.createElement(\"input\");\n            element.type = \"date\";\n            element.required = require;\n            element.placeholder = placeholderText || placeholder_1.placeholder.date(language || 'en');\n            elementTypeClass = \"magicfeedback-date\";\n            if (urlParamValue) {\n                element.value = urlParamValue;\n            }\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.CONSENT:\n            // Create an input element with type \"checkbox\" for BOOLEAN type\n            element = document.createElement(\"input\");\n            elementTypeClass = \"magicfeedback-consent\";\n            element.type = \"checkbox\";\n            element.id = `magicfeedback-${id}`;\n            element.name = ref;\n            element.value = \"true\";\n            element.required = require;\n            element.classList.add(\"magicfeedback-consent\");\n            element.classList.add(\"magicfeedback-input\");\n            if (urlParamValue && value.includes(urlParamValue)) {\n                element.checked = true;\n            }\n            if (send) {\n                element.addEventListener(\"change\", () => {\n                    send();\n                });\n            }\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.EMAIL:\n            // Create an input element with type \"email\" for EMAIL type\n            element = document.createElement(\"input\");\n            element.type = \"email\";\n            element.required = require;\n            element.placeholder = placeholderText || \"you@example.com\";\n            elementTypeClass = \"magicfeedback-email\";\n            if (urlParamValue) {\n                element.value = urlParamValue;\n            }\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.PASSWORD:\n            // Create an input element with type \"password\" for PASSWORD type\n            element = document.createElement(\"input\");\n            element.type = \"password\";\n            element.required = require;\n            element.placeholder = placeholderText || placeholder_1.placeholder.password(language || 'en');\n            elementTypeClass = \"magicfeedback-password\";\n            if (urlParamValue) {\n                element.value = urlParamValue;\n            }\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.MULTI_QUESTION_MATRIX:\n            element = document.createElement(\"div\");\n            elementTypeClass = \"magicfeedback-multi-question-matrix\";\n            const matrixContainer = document.createElement(\"div\");\n            matrixContainer.classList.add(\"magicfeedback-multi-question-matrix-container\");\n            let options = (assets === null || assets === void 0 ? void 0 : assets.options) || [];\n            let values = [...value];\n            let exclusiveValues = [];\n            if (randomPosition) {\n                options = options === null || options === void 0 ? void 0 : options.sort(() => Math.random() - 0.5);\n                values = [...values].sort(() => Math.random() - 0.5);\n            }\n            if (assets === null || assets === void 0 ? void 0 : assets.exclusiveAnswers) {\n                exclusiveValues = assets === null || assets === void 0 ? void 0 : assets.exclusiveAnswers;\n                exclusiveValues === null || exclusiveValues === void 0 ? void 0 : exclusiveValues.forEach((answer) => {\n                    if (!values.includes(answer))\n                        values.push(answer);\n                });\n            }\n            if (window.innerWidth < 600) {\n                const list = document.createElement(\"div\");\n                list.classList.add(\"magicfeedback-multi-question-matrix-list\");\n                // Add the questions as rows\n                options === null || options === void 0 ? void 0 : options.forEach((question) => {\n                    const row = document.createElement(\"div\");\n                    row.classList.add(\"magicfeedback-multi-question-matrix-list-item\");\n                    row.style.display = \"flex\";\n                    row.style.flexDirection = \"column\";\n                    row.style.alignItems = \"flex-start\";\n                    row.style.marginBottom = \"10px\";\n                    // Add the question label as the first cell\n                    const label = document.createElement(\"label\");\n                    label.classList.add(\"magicfeedback-multi-question-matrix-label\");\n                    label.style.paddingBottom = \"10px\";\n                    label.textContent = question;\n                    row.appendChild(label);\n                    // Add the options as radio buttons, one by line\n                    values.forEach((option) => {\n                        const container = document.createElement(\"div\");\n                        container.classList.add(`magicfeedback-radio-container`);\n                        container.style.display = \"flex\";\n                        container.style.alignItems = \"center\";\n                        container.style.justifyContent = \"flex-start\";\n                        container.style.width = \"99%\";\n                        container.style.margin = \"5px auto\";\n                        const label = document.createElement(\"label\");\n                        const input = document.createElement(\"input\");\n                        input.id = `${ref}-${question}-${option}`;\n                        input.type = \"radio\";\n                        input.name = `${ref}-${question}`;\n                        input.value = option;\n                        input.classList.add(\"magicfeedback-input\");\n                        label.textContent = option;\n                        label.htmlFor = `${ref}-${question}-${option}`;\n                        container.appendChild(input);\n                        container.appendChild(label);\n                        row.appendChild(container);\n                    });\n                    list.appendChild(row);\n                });\n                matrixContainer.appendChild(list);\n            }\n            else {\n                //The matrix have a table format with the questions in the rows and the options in the columns, all the options have a title in the header of the column and is posssioble select moere than one option per question\n                const table = document.createElement(\"table\");\n                table.classList.add(\"magicfeedback-multi-question-matrix-table\");\n                // Create the header of the table\n                const header = document.createElement(\"thead\");\n                header.classList.add(\"magicfeedback-multi-question-matrix-header\");\n                header.style.paddingBottom = \"15px\";\n                const headerRow = document.createElement(\"tr\");\n                // Add an empty cell for the question column\n                const emptyHeaderCell = document.createElement(\"th\");\n                headerRow.appendChild(emptyHeaderCell);\n                // Add the options as column headers\n                values.forEach((option) => {\n                    const headerCell = document.createElement(\"th\");\n                    headerCell.textContent = option;\n                    headerRow.appendChild(headerCell);\n                });\n                header.appendChild(headerRow);\n                table.appendChild(header);\n                // Create the body of the table\n                const body = document.createElement(\"tbody\");\n                // Add the questions as rows\n                options === null || options === void 0 ? void 0 : options.forEach((question) => {\n                    const row = document.createElement(\"tr\");\n                    row.classList.add(\"magicfeedback-multi-question-matrix-row-tr\");\n                    // Add the question label as the first cell\n                    const questionCell = document.createElement(\"td\");\n                    questionCell.style.minWidth = \"200px\";\n                    questionCell.style.padding = \"10px\";\n                    const label = document.createElement(\"label\");\n                    label.classList.add(\"magicfeedback-multi-question-matrix-label\");\n                    label.textContent = question;\n                    questionCell.appendChild(label);\n                    row.appendChild(questionCell);\n                    // Add the options as radio buttons or checkboxes\n                    values.forEach((option) => {\n                        const optionCell = document.createElement(\"td\");\n                        const input = document.createElement(\"input\");\n                        input.type = \"radio\";\n                        input.name = `${ref}-${question}`;\n                        input.value = option;\n                        input.id = `${ref}-${question}-${option}`;\n                        input.classList.add(\"magicfeedback-input\");\n                        optionCell.appendChild(input);\n                        row.appendChild(optionCell);\n                    });\n                    body.appendChild(row);\n                });\n                table.appendChild(body);\n                matrixContainer.appendChild(table);\n            }\n            element.appendChild(matrixContainer);\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.PRIORITY_LIST:\n            element = document.createElement(\"div\");\n            elementTypeClass = \"magicfeedback-priority-list\";\n            const priorityListContainer = document.createElement(\"div\");\n            priorityListContainer.classList.add(\"magicfeedback-priority-list-container\");\n            // The priority list have a list of items that the user can order by priority,\n            // the item is a card with the number of the position and title in the left and a\n            // arrow up and down to change the position of the item\n            const list = document.createElement(\"ul\");\n            list.classList.add(\"magicfeedback-priority-list-list\");\n            if (randomPosition) {\n                value = value.sort(() => Math.random() - 0.5);\n            }\n            value.forEach((option, index) => {\n                const item = document.createElement(\"li\");\n                item.classList.add(\"magicfeedback-priority-list-item\");\n                item.style.display = \"flex\";\n                item.style.justifyContent = \"space-between\";\n                item.style.alignItems = \"center\";\n                item.style.margin = \"5px\";\n                // Add input position\n                const input = document.createElement(\"input\");\n                input.classList.add(\"magicfeedback-input-magicfeedback-priority-list\");\n                input.classList.add(\"magicfeedback-input\");\n                input.type = \"hidden\";\n                input.id = `priority-list-${ref}`;\n                input.name = ref;\n                input.value = `${index + 1}. ${option}`;\n                item.appendChild(input);\n                const itemLabel = document.createElement(\"label\");\n                itemLabel.classList.add(\"magicfeedback-priority-list-item-label\");\n                itemLabel.textContent = `${index + 1}. ${option}`;\n                item.appendChild(itemLabel);\n                const arrowContainer = document.createElement(\"div\");\n                arrowContainer.style.display = \"flex\";\n                arrowContainer.style.alignItems = \"center\";\n                arrowContainer.style.justifyContent = \"space-between\";\n                const upArrow = document.createElement(\"img\");\n                upArrow.classList.add(\"magicfeedback-priority-list-arrow-up\");\n                // Add a up arrow svg icon\n                upArrow.src = \"https://magicfeedback-c6458-dev.web.app/assets/arrow.svg\";\n                upArrow.style.width = \"20px\";\n                upArrow.style.height = \"20px\";\n                upArrow.style.cursor = \"pointer\";\n                upArrow.style.margin = \"0 5px\";\n                upArrow.style.color = \"#000\";\n                upArrow.style.visibility = index === 0 ? \"hidden\" : \"visible\";\n                upArrow.addEventListener(\"click\", () => {\n                    var _a, _b, _c, _d;\n                    const previous = item.previousElementSibling;\n                    if (previous) {\n                        const position = Number((_a = input.value) === null || _a === void 0 ? void 0 : _a.split(\".\")[0]) - 1;\n                        input.value = `${position}. ${option}`;\n                        itemLabel.textContent = `${position}. ${option}`;\n                        upArrow.style.visibility = position === 1 ? \"hidden\" : \"visible\";\n                        downArrow.style.visibility = position === value.length ? \"hidden\" : \"visible\";\n                        // Update the value of the item that had the new value to update the order\n                        const previousInput = previous.querySelector(\".magicfeedback-input-magicfeedback-priority-list\");\n                        const previousLabel = previous.querySelector(\".magicfeedback-priority-list-item-label\");\n                        const previousArrowUp = previous.querySelector(\".magicfeedback-priority-list-arrow-up\");\n                        const previousArrowDown = previous.querySelector(\".magicfeedback-priority-list-arrow-down\");\n                        if (previousInput && previousLabel && previousArrowUp && previousArrowDown) {\n                            const newPosition = Number((_b = previousInput.value) === null || _b === void 0 ? void 0 : _b.split(\".\")[0]) + 1;\n                            previousInput.value = `${newPosition}.${(_c = previousLabel.textContent) === null || _c === void 0 ? void 0 : _c.split(\".\")[1]}`;\n                            previousLabel.textContent = `${newPosition}.${(_d = previousLabel.textContent) === null || _d === void 0 ? void 0 : _d.split(\".\")[1]}`;\n                            previousArrowUp.style.visibility = newPosition === 1 ? \"hidden\" : \"visible\";\n                            previousArrowDown.style.visibility = newPosition === value.length ? \"hidden\" : \"visible\";\n                        }\n                        list.insertBefore(item, previous);\n                    }\n                });\n                arrowContainer.appendChild(upArrow);\n                const downArrow = document.createElement(\"img\");\n                downArrow.classList.add(\"magicfeedback-priority-list-arrow-down\");\n                // Add a down arrow svg icon\n                downArrow.src = \"https://magicfeedback-c6458-dev.web.app/assets/arrow.svg\";\n                downArrow.style.width = \"20px\";\n                downArrow.style.height = \"20px\";\n                downArrow.style.cursor = \"pointer\";\n                downArrow.style.margin = \"0 5px\";\n                downArrow.style.color = \"#000\";\n                downArrow.style.transform = \"rotate(180deg)\";\n                // Hidden if is the bottom\n                downArrow.style.visibility = index === value.length - 1 ? \"hidden\" : \"visible\";\n                downArrow.addEventListener(\"click\", () => {\n                    var _a, _b, _c;\n                    const next = item.nextElementSibling;\n                    if (next) {\n                        const position = Number((_a = input.value) === null || _a === void 0 ? void 0 : _a.split(\".\")[0]) + 1;\n                        input.value = position.toString();\n                        itemLabel.textContent = `${position.toString()}. ${option}`;\n                        upArrow.style.visibility = position === 1 ? \"hidden\" : \"visible\";\n                        downArrow.style.visibility = position === value.length ? \"hidden\" : \"visible\";\n                        // Update the value of the item that had the new value to update the order\n                        const nextInput = next.querySelector(\".magicfeedback-input-magicfeedback-priority-list\");\n                        const nextLabel = next.querySelector(\".magicfeedback-priority-list-item-label\");\n                        const nextArrowUp = next.querySelector(\".magicfeedback-priority-list-arrow-up\");\n                        const nextArrowDown = next.querySelector(\".magicfeedback-priority-list-arrow-down\");\n                        if (nextInput && nextLabel && nextArrowUp && nextArrowDown) {\n                            const newPosition = Number(nextInput.value.split(\".\")[0]) - 1;\n                            nextInput.value = `${newPosition}.${(_b = nextLabel.textContent) === null || _b === void 0 ? void 0 : _b.split(\".\")[1]}`;\n                            nextLabel.textContent = `${newPosition}.${(_c = nextLabel.textContent) === null || _c === void 0 ? void 0 : _c.split(\".\")[1]}`;\n                            nextArrowUp.style.visibility = newPosition === 1 ? \"hidden\" : \"visible\";\n                            nextArrowDown.style.visibility = newPosition === value.length ? \"hidden\" : \"visible\";\n                        }\n                        list.insertBefore(next, item);\n                    }\n                });\n                arrowContainer.appendChild(downArrow);\n                item.appendChild(arrowContainer);\n                list.appendChild(item);\n            });\n            priorityListContainer.appendChild(list);\n            element.appendChild(priorityListContainer);\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.POINT_SYSTEM:\n            element = document.createElement(\"div\");\n            elementTypeClass = \"magicfeedback-point-system\";\n            const pointSystemContainer = document.createElement(\"div\");\n            pointSystemContainer.classList.add(\"magicfeedback-point-system-container\");\n            // The point system have a list of items that the user can assign a value, the user can assign a value to each item in % of the total points but the total points can't be more than 100\n            const pointSystemList = document.createElement(\"ul\");\n            pointSystemList.classList.add(\"magicfeedback-point-system-list\");\n            pointSystemList.style.padding = \"0\";\n            const totalPoints = 100;\n            const pointsPerItem = totalPoints / value.length;\n            // Add error message to say that the 100 % is mandatory\n            const errorMessage = document.createElement(\"div\");\n            errorMessage.classList.add(\"magicfeedback-error\");\n            errorMessage.textContent = placeholder_1.placeholder.pointsystemerror(language || 'en');\n            errorMessage.style.color = \"#C70039\";\n            errorMessage.style.fontSize = \"14px\";\n            errorMessage.style.textAlign = \"right\";\n            errorMessage.style.width = \"100%\";\n            errorMessage.style.display = \"none\";\n            //Add a total points counter\n            const totalPointsContainer = document.createElement(\"div\");\n            totalPointsContainer.classList.add(\"magicfeedback-point-system-total\");\n            totalPointsContainer.textContent = `0 / 100 %`;\n            totalPointsContainer.style.textAlign = \"right\";\n            totalPointsContainer.style.fontSize = \"15px\";\n            totalPointsContainer.style.marginTop = \"5px\";\n            value.forEach((option, index) => {\n                const item = document.createElement(\"li\");\n                item.classList.add(\"magicfeedback-point-system-item\");\n                item.style.display = \"flex\";\n                item.style.justifyContent = \"space-between\";\n                item.style.alignItems = \"center\";\n                item.style.margin = \"5px\";\n                const itemLabel = document.createElement(\"label\");\n                itemLabel.textContent = option;\n                itemLabel.style.fontSize = \"15px\";\n                item.appendChild(itemLabel);\n                const inputContainer = document.createElement(\"span\");\n                inputContainer.classList.add(\"magicfeedback-point-system-input-container\");\n                const itemInput = document.createElement(\"input\");\n                itemInput.name = ref;\n                itemInput.id = `${option}`;\n                itemInput.type = \"number\";\n                itemInput.min = \"0\";\n                itemInput.max = `${totalPoints}`;\n                itemInput.value = `0`;\n                itemInput.classList.add(\"magicfeedback-input\");\n                itemInput.style.width = \"40px\";\n                itemInput.style.border = \"0\";\n                itemInput.style.textAlign = \"center\";\n                itemInput.style.margin = \"0 5px\";\n                itemInput.autofocus = index === 0;\n                // Add the % symbol to the input\n                const percentSymbol = document.createElement(\"span\");\n                percentSymbol.textContent = \"%\";\n                percentSymbol.style.color = \"#000\";\n                // Control the total points assigned to the items\n                itemInput.addEventListener(\"input\", () => {\n                    const allInputs = pointSystemList.querySelectorAll(\"input\");\n                    let total = 0;\n                    allInputs.forEach((input) => {\n                        total += Number(input.value);\n                    });\n                    if (total > totalPoints) {\n                        itemInput.value = `${pointsPerItem}%`;\n                        total = total - Number(itemInput.value);\n                    }\n                    const submitButton = document.getElementById(\"magicfeedback-submit\");\n                    if (submitButton) {\n                        if (total < 100) {\n                            // Disable the submit button if the total points are less than 100\n                            totalPointsContainer.style.color = \"orange\";\n                            submitButton.setAttribute(\"disabled\", \"true\");\n                        }\n                        else {\n                            errorMessage.style.display = \"none\";\n                            totalPointsContainer.style.color = \"green\";\n                            submitButton.removeAttribute(\"disabled\");\n                        }\n                    }\n                    totalPointsContainer.textContent = `${total} / 100 %`;\n                });\n                itemInput.addEventListener(\"focus\", () => {\n                    const submitButton = document.getElementById(\"magicfeedback-submit\");\n                    if (submitButton) {\n                        submitButton.setAttribute(\"disabled\", \"true\");\n                        submitButton.addEventListener(\"pointerover\", () => {\n                            const allInputs = pointSystemList.querySelectorAll(\"input\");\n                            let total = 0;\n                            allInputs.forEach((input) => {\n                                total += Number(input.value);\n                            });\n                            if (total < 100)\n                                errorMessage.style.display = \"block\";\n                        });\n                    }\n                });\n                inputContainer.appendChild(itemInput);\n                inputContainer.appendChild(percentSymbol);\n                item.appendChild(inputContainer);\n                pointSystemList.appendChild(item);\n            });\n            pointSystemContainer.appendChild(pointSystemList);\n            pointSystemContainer.appendChild(totalPointsContainer);\n            pointSystemContainer.appendChild(errorMessage);\n            element.appendChild(pointSystemContainer);\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.INFO_PAGE:\n            element = document.createElement(\"div\");\n            elementTypeClass = \"magicfeedback-info-page\";\n            const infoMessageElement = document.createElement(\"div\");\n            infoMessageElement.classList.add(\"magicfeedback-info-message\");\n            infoMessageElement.innerHTML = placeholderText;\n            element.appendChild(infoMessageElement);\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.UPLOAD_IMAGE:\n            element = document.createElement(\"input\");\n            element.type = \"file\";\n            element.accept = \"image/*\";\n            element.required = require;\n            element.multiple = (assets === null || assets === void 0 ? void 0 : assets.multiple) || false;\n            element.maxLength = (assets === null || assets === void 0 ? void 0 : assets.maxFiles) || 1;\n            elementTypeClass = \"magicfeedback-upload-image\";\n            break;\n        case types_1.FEEDBACKAPPANSWERTYPE.UPLOAD_FILE:\n            element = document.createElement(\"input\");\n            element.type = \"file\";\n            element.required = require;\n            element.multiple = (assets === null || assets === void 0 ? void 0 : assets.multiple) || false;\n            element.maxLength = (assets === null || assets === void 0 ? void 0 : assets.maxFiles) || 1;\n            elementTypeClass = \"magicfeedback-upload-file\";\n            break;\n        default:\n            return elementContainer;\n    }\n    element.id = `magicfeedback-${id}`;\n    element.setAttribute(\"name\", ref);\n    element.classList.add(elementTypeClass);\n    if (defaultValue !== undefined || urlParamValue !== null) {\n        element.value = urlParamValue || defaultValue;\n    }\n    if (![\"RADIO\", \"MULTIPLECHOICE\"].includes(type)) {\n        element.classList.add(\"magicfeedback-input\");\n        element.required = require;\n    }\n    // Add the label and input element to the form\n    const label = document.createElement(\"label\");\n    label.setAttribute(\"for\", `magicfeedback-${id}`);\n    label.textContent = parseTitle(title, language);\n    label.classList.add(\"magicfeedback-label\");\n    const subLabel = document.createElement(\"label\");\n    subLabel.textContent = parseTitle(assets === null || assets === void 0 ? void 0 : assets.subtitle, language);\n    subLabel.classList.add(\"magicfeedback-sublabel\");\n    if ((_a = assets === null || assets === void 0 ? void 0 : assets.subtitleStyle) === null || _a === void 0 ? void 0 : _a.includes('italic')) {\n        subLabel.style.fontStyle = \"italic\";\n    }\n    if ((_b = assets === null || assets === void 0 ? void 0 : assets.subtitleStyle) === null || _b === void 0 ? void 0 : _b.includes('bold')) {\n        subLabel.style.fontWeight = \"bold\";\n    }\n    if ((_c = assets === null || assets === void 0 ? void 0 : assets.subtitleStyle) === null || _c === void 0 ? void 0 : _c.includes('underline')) {\n        subLabel.style.textDecoration = \"underline\";\n    }\n    if ([\"CONSENT\"].includes(type)) {\n        elementContainer.classList.add(\"magicfeedback-consent-container\");\n        elementContainer.appendChild(element);\n        elementContainer.appendChild(label);\n        elementContainer.appendChild(subLabel);\n    }\n    else {\n        if (format !== 'slim') {\n            elementContainer.appendChild(label);\n            elementContainer.appendChild(subLabel);\n            if ((assets === null || assets === void 0 ? void 0 : assets.general) !== undefined && (assets === null || assets === void 0 ? void 0 : assets.general) !== \"\") {\n                // Add a image to the form\n                const image = document.createElement(\"img\");\n                image.src = assets === null || assets === void 0 ? void 0 : assets.general;\n                image.classList.add(\"magicfeedback-image\");\n                // Add a max default width to the image\n                image.style.maxWidth = \"auto\";\n                image.style.height = \"400px\";\n                image.style.margin = \"10px 0\";\n                elementContainer.appendChild(image);\n            }\n        }\n        if (type === \"LONGTEXT\" && maxCharacters > 0) {\n            const counter = document.createElement(\"div\");\n            counter.classList.add(\"magicfeedback-counter\");\n            counter.textContent = `${element.value.length}/${maxCharacters}`;\n            counter.style.textAlign = \"right\";\n            counter.style.fontSize = \"15px\";\n            counter.style.marginTop = \"5px\";\n            element.addEventListener(\"input\", () => {\n                counter.textContent = `${element.value.length}/${maxCharacters}`;\n            });\n            elementContainer.appendChild(element);\n            elementContainer.appendChild(counter);\n            if ((assets === null || assets === void 0 ? void 0 : assets.extraOption) && (assets === null || assets === void 0 ? void 0 : assets.extraOptionText)) {\n                const skipContainer = document.createElement(\"div\");\n                skipContainer.classList.add(\"magicfeedback-skip-container\");\n                skipContainer.classList.add(`magicfeedback-checkbox-container`);\n                skipContainer.style.display = \"flex\";\n                skipContainer.style.justifyContent = \"flex-start\";\n                // Option to skip the question checkbox\n                const skipButton = document.createElement(\"input\");\n                skipButton.classList.add(\"magicfeedback-skip\");\n                skipButton.type = \"checkbox\";\n                skipButton.id = `skip-${ref}`;\n                skipButton.name = ref;\n                skipButton.value = '-';\n                skipButton.style.cursor = \"pointer\";\n                const skipLabel = document.createElement(\"label\");\n                skipLabel.htmlFor = `skip-${ref}`;\n                skipLabel.textContent = assets === null || assets === void 0 ? void 0 : assets.extraOptionText;\n                skipLabel.style.fontSize = \"15px\";\n                skipLabel.style.cursor = \"pointer\";\n                skipLabel.style.margin = \"0 5px\";\n                skipButton.addEventListener(\"click\", () => {\n                    element.value = '-';\n                    if (send)\n                        send();\n                });\n                skipContainer.appendChild(skipButton);\n                skipContainer.appendChild(skipLabel);\n                elementContainer.appendChild(skipContainer);\n            }\n        }\n        else {\n            elementContainer.appendChild(element);\n        }\n    }\n    return elementContainer;\n}\nfunction renderActions(identity = '', backAction, sendButtonText = \"Submit\", backButtonText = \"Back\", nextButtonText = \"Next\") {\n    const actionContainer = document.createElement(\"div\");\n    actionContainer.classList.add(\"magicfeedback-action-container\");\n    // Create a submit button if specified in options\n    const submitButton = document.createElement(\"button\");\n    submitButton.id = \"magicfeedback-submit\";\n    submitButton.type = \"submit\";\n    submitButton.classList.add(\"magicfeedback-submit\");\n    submitButton.textContent = identity === 'MAGICSURVEY' ? (nextButtonText || \"Next\") : (sendButtonText || \"Submit\");\n    // Create a back button\n    const backButton = document.createElement(\"button\");\n    backButton.id = \"magicfeedback-back\";\n    backButton.type = \"button\";\n    backButton.classList.add(\"magicfeedback-back\");\n    backButton.textContent = backButtonText || \"Back\";\n    backButton.addEventListener(\"click\", backAction);\n    backButton.addEventListener(\"click\", () => {\n        submitButton.removeAttribute(\"disabled\");\n    });\n    if (identity === 'MAGICSURVEY') {\n        actionContainer.appendChild(backButton);\n    }\n    actionContainer.appendChild(submitButton);\n    return actionContainer;\n}\nexports.renderActions = renderActions;\nfunction createStarRating(ref, minPlaceholder, maxPlaceholder, send = () => {\n}, urlParamValue) {\n    const size = 40;\n    const selectedClass = \"magicfeedback-rating-star-selected\";\n    const starFilled = \"\";\n    const ratingContainer = document.createElement(\"div\");\n    ratingContainer.classList.add(\"magicfeedback-rating-star-container\");\n    ratingContainer.style.maxWidth = \"300px\";\n    ratingContainer.style.margin = \"auto\";\n    // Mantiene el valor seleccionado original para restaurar tras hover\n    ratingContainer.dataset.originalSelection = '0';\n    for (let i = 1; i <= 5; i++) {\n        const ratingOption = document.createElement(\"label\");\n        ratingOption.classList.add(\"magicfeedback-rating-star-option\");\n        // Create hidden radio input\n        const ratingInput = document.createElement(\"input\");\n        ratingInput.id = `rating-${ref}-${i}`;\n        ratingInput.type = \"radio\";\n        ratingInput.name = ref;\n        ratingInput.value = i.toString();\n        ratingInput.style.position = \"absolute\";\n        ratingInput.style.opacity = \"0\";\n        ratingInput.style.width = \"0\";\n        ratingInput.style.height = \"0\";\n        ratingInput.classList.add(\"magicfeedback-input\");\n        if (urlParamValue && urlParamValue === ratingInput.value) {\n            ratingInput.checked = true;\n        }\n        // Update filled stars on radio input change\n        ratingInput.addEventListener(\"change\", () => {\n            const allStars = ratingContainer.querySelectorAll(\".rating__star\");\n            for (let j = 0; j < allStars.length; j++) {\n                if (j + 1 <= Number(ratingInput.value)) {\n                    if (!allStars[j].classList.contains(selectedClass))\n                        allStars[j].classList.add(selectedClass);\n                }\n                else {\n                    if (allStars[j].classList.contains(selectedClass))\n                        allStars[j].classList.remove(selectedClass);\n                }\n            }\n            // Actualizamos el valor original para futuros hover\n            ratingContainer.dataset.originalSelection = ratingInput.value;\n            if (send)\n                send();\n        });\n        ratingOption.appendChild(ratingInput);\n        // Create star element (after for better positioning)\n        const starElement = document.createElement(\"label\");\n        starElement.htmlFor = `rating-${ref}-${i}`;\n        starElement.classList.add(\"rating__star\");\n        starElement.textContent = starFilled;\n        starElement.style.fontSize = `${size}px`; // Set star size\n        starElement.style.color = \"#CCCCCC\"; // Set star color\n        starElement.style.cursor = \"pointer\";\n        // Hover para previsualizar seleccin (amarillear todas las anteriores)\n        starElement.addEventListener(\"mouseenter\", () => {\n            const allStars = ratingContainer.querySelectorAll(\".rating__star\");\n            const idx = i - 1; // ndice de la estrella sobre la que se hace hover\n            allStars.forEach((star, starIdx) => {\n                if (starIdx <= idx) {\n                    if (!star.classList.contains(selectedClass))\n                        star.classList.add(selectedClass);\n                }\n                else {\n                    if (star.classList.contains(selectedClass))\n                        star.classList.remove(selectedClass);\n                }\n            });\n        });\n        // Al salir se restaura la seleccin original\n        starElement.addEventListener(\"mouseleave\", () => {\n            const original = Number(ratingContainer.dataset.originalSelection || '0');\n            const allStars = ratingContainer.querySelectorAll(\".rating__star\");\n            allStars.forEach((star, starIdx) => {\n                if (starIdx < original) {\n                    if (!star.classList.contains(selectedClass))\n                        star.classList.add(selectedClass);\n                }\n                else {\n                    if (star.classList.contains(selectedClass))\n                        star.classList.remove(selectedClass);\n                }\n            });\n        });\n        ratingOption.appendChild(starElement);\n        ratingContainer.appendChild(ratingOption);\n    }\n    ratingContainer.appendChild(createRatingPlaceholder(1, 5, minPlaceholder, maxPlaceholder, false, false));\n    return ratingContainer;\n}\nfunction createRatingPlaceholder(min, max, minPlaceholder, maxPlaceholder, extraOption, mobile = true, order = 'ltr', direction = 'row') {\n    const ratingPlaceholder = document.createElement('div');\n    ratingPlaceholder.classList.add('magicfeedback-rating-placeholder');\n    ratingPlaceholder.style.display = \"flex\";\n    ratingPlaceholder.style.flexDirection = direction;\n    ratingPlaceholder.style.alignItems = \"center\";\n    ratingPlaceholder.style.justifyContent = \"space-between\";\n    ratingPlaceholder.style.width = extraOption ? `calc(100% - (100% / ${max + 1}))` : \"100%\";\n    ratingPlaceholder.style.marginRight = \"auto\";\n    if (mobile && window.innerWidth < 600)\n        ratingPlaceholder.style.flexDirection = \"column\";\n    const ratingPlaceholderMin = document.createElement('span');\n    ratingPlaceholderMin.textContent = minPlaceholder;\n    ratingPlaceholderMin.classList.add('magicfeedback-rating-placeholder-value');\n    ratingPlaceholderMin.style.fontSize = \"15px\";\n    ratingPlaceholderMin.style.textAlign = order === 'ltr' ? \"left\" : \"right\";\n    ratingPlaceholderMin.style.width = `50%`;\n    if (mobile && window.innerWidth < 600 || direction === 'column') {\n        ratingPlaceholderMin.textContent = `${min} = ${minPlaceholder}`;\n        ratingPlaceholderMin.style.width = '100%';\n        ratingPlaceholderMin.style.textAlign = \"left\";\n        ratingPlaceholderMin.style.marginBottom = \"5px\";\n    }\n    const ratingPlaceholderMax = document.createElement('span');\n    ratingPlaceholderMax.textContent = maxPlaceholder;\n    ratingPlaceholderMax.classList.add('magicfeedback-rating-placeholder-value');\n    ratingPlaceholderMax.style.fontSize = \"15px\";\n    ratingPlaceholderMax.style.textAlign = order === 'ltr' ? \"right\" : \"left\";\n    ratingPlaceholderMax.style.width = `50%`;\n    if (mobile && window.innerWidth < 600 || direction === 'column') {\n        ratingPlaceholderMax.textContent = `${max} = ${maxPlaceholder}`;\n        ratingPlaceholderMax.style.width = '100%';\n        ratingPlaceholderMax.style.textAlign = \"left\";\n        ratingPlaceholderMax.style.marginBottom = \"5px\";\n    }\n    if (order === 'ltr') {\n        if (minPlaceholder)\n            ratingPlaceholder.appendChild(ratingPlaceholderMin);\n        if (maxPlaceholder)\n            ratingPlaceholder.appendChild(ratingPlaceholderMax);\n    }\n    else {\n        if (maxPlaceholder)\n            ratingPlaceholder.appendChild(ratingPlaceholderMax);\n        if (minPlaceholder)\n            ratingPlaceholder.appendChild(ratingPlaceholderMin);\n    }\n    return ratingPlaceholder;\n}\nfunction renderError(error) {\n    const errorElement = document.createElement(\"div\");\n    errorElement.classList.add(\"magicfeedback-error\");\n    errorElement.textContent = error;\n    return errorElement;\n}\nexports.renderError = renderError;\nfunction renderSuccess(success) {\n    const successElement = document.createElement(\"div\");\n    successElement.classList.add(\"magicfeedback-success\");\n    successElement.textContent = success;\n    return successElement;\n}\nexports.renderSuccess = renderSuccess;\nfunction renderStartMessage(startMessage, addButton = false, startButtonText = \"Go!\", startEvent = () => {\n}) {\n    const startMessageContainer = document.createElement(\"div\");\n    startMessageContainer.classList.add(\"magicfeedback-start-message-container\");\n    const startMessageElement = document.createElement(\"div\");\n    startMessageElement.classList.add(\"magicfeedback-start-message\");\n    startMessageElement.innerHTML = startMessage;\n    startMessageContainer.appendChild(startMessageElement);\n    if (addButton) {\n        const startMessageButton = document.createElement(\"button\");\n        startMessageButton.id = \"magicfeedback-start-message-button\";\n        startMessageButton.classList.add(\"magicfeedback-start-message-button\");\n        startMessageButton.textContent = startButtonText;\n        startMessageButton.addEventListener(\"click\", () => startEvent());\n        startMessageContainer.appendChild(startMessageButton);\n    }\n    return startMessageContainer;\n}\nexports.renderStartMessage = renderStartMessage;\nfunction createRatingNumberElement(ref, assets, order, direction, isPhone, elementTypeClass, send, urlParamValue) {\n    const element = document.createElement(\"div\");\n    element.classList.add('magicfeedback-rating-number');\n    const numberContainerDirection = order === 'ltr' ? direction : `${direction}-reverse`;\n    const ratingNumberContainer = document.createElement('div');\n    ratingNumberContainer.classList.add('magicfeedback-rating-number-container');\n    ratingNumberContainer.classList.add(`magicfeedback-rating-number-container-${order}`);\n    ratingNumberContainer.classList.add(`magicfeedback-rating-number-container-${direction}`);\n    ratingNumberContainer.style.display = \"flex\";\n    ratingNumberContainer.style.flexDirection = numberContainerDirection;\n    ratingNumberContainer.setAttribute('role', 'radiogroup');\n    ratingNumberContainer.setAttribute('aria-label', (assets === null || assets === void 0 ? void 0 : assets.ariaLabel) || 'Rating');\n    const maxRatingNumber = (assets === null || assets === void 0 ? void 0 : assets.max) ? Number(assets === null || assets === void 0 ? void 0 : assets.max) : 10;\n    const minRatingNumber = (assets === null || assets === void 0 ? void 0 : assets.min) ? Number(assets === null || assets === void 0 ? void 0 : assets.min) : 0;\n    const integratePlaceholders = !(isPhone || direction === 'column');\n    for (let i = minRatingNumber; i <= maxRatingNumber; i++) {\n        const ratingOption = document.createElement('div');\n        ratingOption.classList.add('magicfeedback-rating-number-option');\n        ratingOption.classList.add(`magicfeedback-rating-number-option-${direction}`);\n        const containerLabel = document.createElement('label');\n        containerLabel.htmlFor = `rating-${ref}-${i}`;\n        containerLabel.classList.add('magicfeedback-rating-number-option-label-container');\n        if (integratePlaceholders) {\n            containerLabel.style.position = 'relative';\n            containerLabel.style.overflow = 'visible';\n        }\n        // Cap span (placeholder visual) para todas las opciones para mantener altura uniforme\n        if (integratePlaceholders) {\n            const cap = document.createElement('span');\n            cap.classList.add('magicfeedback-rating-number-cap');\n            cap.classList.add('magicfeedback-rating-placeholder-value');\n            cap.style.fontSize = \"14px\";\n            cap.style.whiteSpace = 'nowrap';\n            cap.style.wordBreak = 'normal';\n            if (i === minRatingNumber && (assets === null || assets === void 0 ? void 0 : assets.minPlaceholder)) {\n                cap.textContent = assets.minPlaceholder;\n                cap.dataset.capType = 'min';\n            }\n            else if (i === maxRatingNumber && (assets === null || assets === void 0 ? void 0 : assets.maxPlaceholder)) {\n                cap.textContent = assets.maxPlaceholder;\n                cap.dataset.capType = 'max';\n            }\n            else\n                cap.dataset.capType = 'mid';\n            containerLabel.appendChild(cap);\n        }\n        let inputText = i.toString();\n        if (!integratePlaceholders) {\n            if (i === minRatingNumber && (assets === null || assets === void 0 ? void 0 : assets.minPlaceholder))\n                inputText += ` = ${assets === null || assets === void 0 ? void 0 : assets.minPlaceholder}`;\n            if (i === maxRatingNumber && (assets === null || assets === void 0 ? void 0 : assets.maxPlaceholder))\n                inputText += ` = ${assets === null || assets === void 0 ? void 0 : assets.maxPlaceholder}`;\n        }\n        const input = document.createElement(\"input\");\n        input.id = `rating-${ref}-${i}`;\n        input.type = \"radio\";\n        input.name = ref;\n        input.value = i.toString();\n        input.classList.add(elementTypeClass);\n        input.classList.add(\"magicfeedback-input\");\n        input.setAttribute('aria-label', `${i}`);\n        if (send)\n            input.addEventListener(\"change\", () => send());\n        if (urlParamValue && urlParamValue === input.value) {\n            input.checked = true;\n        }\n        const ratingLabel = document.createElement('label');\n        ratingLabel.htmlFor = `rating-${ref}-${i}`;\n        ratingLabel.textContent = inputText;\n        ratingLabel.classList.add('magicfeedback-rating-number-value');\n        containerLabel.appendChild(input);\n        containerLabel.appendChild(ratingLabel);\n        ratingOption.appendChild(containerLabel);\n        ratingNumberContainer.appendChild(ratingOption);\n    }\n    if ((assets === null || assets === void 0 ? void 0 : assets.extraOption) && (assets === null || assets === void 0 ? void 0 : assets.extraOptionText)) {\n        const extraOption = document.createElement('div');\n        extraOption.classList.add('magicfeedback-rating-number-option');\n        const containerLabel = document.createElement('label');\n        containerLabel.htmlFor = `rating-${ref}-extra`;\n        containerLabel.classList.add('magicfeedback-rating-number-option-label-container');\n        if (integratePlaceholders) {\n            containerLabel.style.position = 'relative';\n            containerLabel.style.overflow = 'visible';\n        }\n        if (integratePlaceholders) {\n            const cap = document.createElement('span');\n            cap.classList.add('magicfeedback-rating-number-cap');\n            cap.dataset.capType = 'extra';\n            cap.style.fontSize = '12px';\n            cap.style.whiteSpace = 'nowrap';\n            cap.style.wordBreak = 'normal';\n            containerLabel.appendChild(cap);\n        }\n        const input = document.createElement(\"input\");\n        input.id = `rating-${ref}-extra`;\n        input.type = \"radio\";\n        input.name = ref;\n        input.value = '-';\n        input.classList.add(elementTypeClass);\n        input.classList.add(\"magicfeedback-input\");\n        input.setAttribute('aria-label', assets === null || assets === void 0 ? void 0 : assets.extraOptionText);\n        if (send)\n            input.addEventListener(\"change\", () => send());\n        const ratingLabel = document.createElement('label');\n        ratingLabel.htmlFor = `rating-${ref}-extra`;\n        ratingLabel.textContent = assets === null || assets === void 0 ? void 0 : assets.extraOptionText;\n        ratingLabel.classList.add('magicfeedback-rating-number-value');\n        containerLabel.appendChild(input);\n        containerLabel.appendChild(ratingLabel);\n        extraOption.appendChild(containerLabel);\n        if (order === 'ltr')\n            ratingNumberContainer.appendChild(extraOption);\n        else\n            ratingNumberContainer.insertBefore(extraOption, ratingNumberContainer.firstChild);\n    }\n    element.appendChild(ratingNumberContainer);\n    // Normalizar alturas de los caps slo en desktop/row\n    if (integratePlaceholders) {\n        requestAnimationFrame(() => {\n            const caps = Array.from(ratingNumberContainer.querySelectorAll('.magicfeedback-rating-number-cap'));\n            if (caps.length === 0)\n                return;\n            const gap = 6;\n            let maxH = 0;\n            caps.forEach(c => {\n                var _a;\n                if ((_a = c.textContent) === null || _a === void 0 ? void 0 : _a.trim()) {\n                    const h = c.getBoundingClientRect().height || 0;\n                    if (h > maxH)\n                        maxH = h;\n                }\n            });\n            ratingNumberContainer.style.position = 'relative';\n            ratingNumberContainer.style.paddingTop = `${maxH === 0 ? '42' : (maxH + gap)}px`;\n            caps.forEach(c => {\n                const h = c.getBoundingClientRect().height || 0;\n                console.log(maxH, h, gap);\n                c.style.position = 'absolute';\n                c.style.top = `-${maxH === 0 ? '42' : (maxH + h)}px`;\n                c.style.zIndex = '1';\n                c.style.pointerEvents = 'none';\n                c.style.padding = '0';\n                c.style.boxSizing = 'border-box';\n                c.style.whiteSpace = 'nowrap';\n                c.style.wordBreak = 'normal';\n                c.style.maxWidth = 'none';\n                c.style.width = 'max-content';\n                // Posicionamiento segn tipo\n                const type = c.dataset.capType;\n                if (type === 'min') {\n                    if (order === 'ltr') {\n                        c.style.left = '10px';\n                        c.style.textAlign = 'left';\n                    }\n                    else {\n                        c.style.right = '10px';\n                        c.style.textAlign = 'right';\n                    }\n                    c.style.transform = 'none';\n                }\n                else if (type === 'max') {\n                    if (order === 'ltr') {\n                        c.style.right = '10px';\n                        c.style.textAlign = 'right';\n                    }\n                    else {\n                        c.style.left = '10px';\n                        c.style.textAlign = 'left';\n                    }\n                    c.style.transform = 'none';\n                }\n                else {\n                    // mid / extra (vacos) centrados sobre su botn pero invisibles en prctica\n                    c.style.left = '50%';\n                    c.style.transform = 'translateX(-50%)';\n                    c.style.textAlign = 'center';\n                }\n            });\n            ratingNumberContainer.style.overflow = 'visible';\n        });\n    }\n    return element;\n}\n\n\n//# sourceURL=webpack://magicfeedback/./src/services/questions.service.ts?");

/***/ }),

/***/ "./src/services/request.service.ts":
/*!*****************************************!*\
  !*** ./src/services/request.service.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getFollowUpQuestion = exports.sendFeedback = exports.getQuestions = exports.getSessionForm = exports.getForm = exports.validateEmail = void 0;\nconst cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ \"./node_modules/cross-fetch/dist/browser-ponyfill.js\"));\nconst package_json_1 = __importDefault(__webpack_require__(/*! ../../package.json */ \"./package.json\"));\nconst paths_1 = __webpack_require__(/*! ./paths */ \"./src/services/paths.ts\");\nconst header = {\n    Accept: \"application/json\",\n    \"Magicfeedback-Sdk-Version\": package_json_1.default.version,\n    \"x-magicfeedback-parameters\": window.location.search || \"\",\n};\n// @ts-ignore\nconst serializedParams = (params) => Object.entries(params).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`).join(\"&\");\nfunction validateEmail(email) {\n    const re = /\\S+@\\S+\\.\\S+/;\n    return re.test(email);\n}\nexports.validateEmail = validateEmail;\nfunction getForm(url, appId, publicKey, log) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const response = yield (0, cross_fetch_1.default)(url + paths_1.endpoints.sdk.app_info(appId, publicKey), {\n                method: \"GET\",\n                headers: header\n            });\n            // Handle success response\n            return yield response.json();\n        }\n        catch (e) {\n            log.err(e);\n        }\n    });\n}\nexports.getForm = getForm;\nfunction getSessionForm(url, sessionId, log) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const response = yield (0, cross_fetch_1.default)(url + paths_1.endpoints.sdk.session(sessionId), {\n                method: \"GET\",\n                headers: header\n            });\n            // Handle success response\n            return yield response.json();\n        }\n        catch (e) {\n            log.err(e);\n        }\n    });\n}\nexports.getSessionForm = getSessionForm;\nfunction getQuestions(url, appId, publicKey, log) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const response = yield (0, cross_fetch_1.default)(url + paths_1.endpoints.sdk.app(appId, publicKey), {\n                method: \"GET\",\n                headers: header\n            });\n            if (response.ok) {\n                // Handle success response\n                const json = yield response.json();\n                log.log(`Received questions for app ${appId}`, json);\n                return json;\n            }\n            else {\n                // Handle error response\n                log.err(`Failed to get questions for app ${appId}:`, response.status, response.statusText);\n                throw new Error(\"[MagicFeedback] Bad response from server\");\n            }\n        }\n        catch (e) {\n            log.err(e);\n            return [];\n        }\n    });\n}\nexports.getQuestions = getQuestions;\nfunction sendFeedback(url, body, log) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const response = yield (0, cross_fetch_1.default)(url + paths_1.endpoints.sdk.feedback, {\n                method: \"POST\",\n                headers: Object.assign({ \"Content-Type\": \"application/json\" }, header),\n                body: JSON.stringify(body),\n            });\n            if (response.ok) {\n                // Handle success response\n                log.log(`Form ${body.integration} submitted successfully!`);\n                // You can perform additional actions here if needed\n                const responseJson = yield response.json();\n                return responseJson.sessionId;\n            }\n            else {\n                // Handle error response\n                log.err(`Failed to submit form ${body.integration}:`, response.status, response.statusText);\n                throw new Error(response.statusText);\n            }\n        }\n        catch (e) {\n            log.err(e);\n            return '';\n        }\n    });\n}\nexports.sendFeedback = sendFeedback;\nfunction getFollowUpQuestion(url, body, log) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const response = yield (0, cross_fetch_1.default)(url + paths_1.endpoints.sdk.followUpQuestion, {\n                method: \"POST\",\n                headers: Object.assign({ \"Content-Type\": \"application/json\" }, header),\n                body: JSON.stringify(body),\n            });\n            if (response.ok) {\n                // Handle success response\n                log.log(`Received follow up question for form ${body.integration}`);\n                // You can perform additional actions here if needed\n                const responseJson = yield response.json();\n                return responseJson || '';\n            }\n            else {\n                // Handle error response\n                log.err(`Failed to get follow up question for form ${body.integration}:`, response.status, response.statusText);\n                throw new Error(response.statusText);\n            }\n        }\n        catch (e) {\n            log.err(e);\n            return '';\n        }\n    });\n}\nexports.getFollowUpQuestion = getFollowUpQuestion;\n\n\n//# sourceURL=webpack://magicfeedback/./src/services/request.service.ts?");

/***/ }),

/***/ "./src/utils/log.ts":
/*!**************************!*\
  !*** ./src/utils/log.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Log = void 0;\nclass Log {\n    /**\n     *\n     * @param config\n     */\n    constructor(config) {\n        // Config\n        this.config = config;\n    }\n    /**\n     *\n     * @param args\n     */\n    log(...args) {\n        if (this.config.get(\"debug\")) {\n            console.log(\"[MagicFeedback]:\", ...args);\n        }\n    }\n    /**\n     *\n     * @param args\n     */\n    err(...args) {\n        console.error(\"[MagicFeedback]:\", ...args);\n    }\n}\nexports.Log = Log;\n\n\n//# sourceURL=webpack://magicfeedback/./src/utils/log.ts?");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"name\":\"@magicfeedback/native\",\"version\":\"2.1.2-beta.7\",\"main\":\"./dist/magicfeedback-sdk.node.js\",\"browser\":\"./dist/magicfeedback-sdk.browser.js\",\"types\":\"./dist/types/src/index.d.ts\",\"repository\":{\"type\":\"git\",\"url\":\"git+ssh://git@github.com/MagicFeedback/magicfeedback-sdk.git\"},\"author\":\"farias@magicfeedback.io\",\"license\":\"MIT\",\"private\":false,\"scripts\":{\"dev\":\"vite\",\"build\":\"webpack\",\"build:watch\":\"webpack --watch --mode development\",\"publish\":\"npm publish --access public\",\"publish:beta\":\"npm publish --access public --tag beta\",\"publish:alpha\":\"npm publish --access public --tag alpha\",\"test\":\"jest\",\"test:watch\":\"jest --watchAll\",\"coverage\":\"vitest run --coverage\"},\"files\":[\"dist\"],\"devDependencies\":{\"@babel/preset-typescript\":\"^7.22.5\",\"@types/node\":\"^17.0.21\",\"@types/webpack\":\"^5.28.0\",\"@types/webpack-node-externals\":\"^2.5.3\",\"c8\":\"^7.11.0\",\"copy-webpack-plugin\":\"^11.0.0\",\"jest\":\"^29.5.0\",\"jest-environment-jsdom\":\"^29.5.0\",\"jest-fetch-mock\":\"^3.0.3\",\"nock\":\"^13.2.4\",\"ts-jest\":\"^29.1.0\",\"ts-loader\":\"^9.2.7\",\"ts-node\":\"^10.7.0\",\"typescript\":\"^4.6.2\",\"vite\":\"^2.8.0\",\"vite-plugin-dts\":\"^0.9.9\",\"vitest\":\"^0.5.9\",\"webpack\":\"^5.70.0\",\"webpack-cli\":\"^4.9.2\",\"webpack-node-externals\":\"^3.0.0\"},\"dependencies\":{\"cross-fetch\":\"^3.1.5\",\"is-bundling-for-browser-or-node\":\"^1.1.1\"},\"description\":\"MagicFeedbackAI JavaScript Library for [MagicFeedback.io](https://magicfeedback.io/)\",\"bugs\":{\"url\":\"https://github.com/MagicFeedback/magicfeedback-sdk/issues\"},\"homepage\":\"https://github.com/MagicFeedback/magicfeedback-sdk#readme\",\"directories\":{\"example\":\"examples\",\"test\":\"test\"},\"style\":\"./dist/styles/magicfeedback-default.css\"}');\n\n//# sourceURL=webpack://magicfeedback/./package.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});